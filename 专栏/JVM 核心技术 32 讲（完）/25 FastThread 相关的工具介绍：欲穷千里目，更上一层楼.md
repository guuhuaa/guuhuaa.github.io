<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
    </head>

<body>

<div class="book-container">
    <div class="book-sidebar">
        <div class="book-brand">
            <a href="../../index.html">
                <img src="../../static/favicon.png">
                <span>技术文章摘抄</span>
            </a>
        </div>
        <div class="book-menu uncollapsible">
            <ul class="uncollapsible">
                <li><a href="../../index.html" class="current-tab">首页</a></li>
            </ul>

            <ul class="uncollapsible">
                <li><a href="../index.html">上一级</a></li>
            </ul>

            <ul class="uncollapsible">
                <li>

                    
                    <a href="01&#32;阅读此专栏的正确姿势.md">01 阅读此专栏的正确姿势.md</a>

                </li>
                <li>

                    
                    <a href="02&#32;环境准备：千里之行，始于足下.md">02 环境准备：千里之行，始于足下.md</a>

                </li>
                <li>

                    
                    <a href="03&#32;常用性能指标：没有量化，就没有改进.md">03 常用性能指标：没有量化，就没有改进.md</a>

                </li>
                <li>

                    
                    <a href="04&#32;JVM&#32;基础知识：不积跬步，无以至千里.md">04 JVM 基础知识：不积跬步，无以至千里.md</a>

                </li>
                <li>

                    
                    <a href="05&#32;Java&#32;字节码技术：不积细流，无以成江河.md">05 Java 字节码技术：不积细流，无以成江河.md</a>

                </li>
                <li>

                    
                    <a href="06&#32;Java&#32;类加载器：山不辞土，故能成其高.md">06 Java 类加载器：山不辞土，故能成其高.md</a>

                </li>
                <li>

                    
                    <a href="07&#32;Java&#32;内存模型：海不辞水，故能成其深.md">07 Java 内存模型：海不辞水，故能成其深.md</a>

                </li>
                <li>

                    
                    <a href="08&#32;JVM&#32;启动参数详解：博观而约取、厚积而薄发.md">08 JVM 启动参数详解：博观而约取、厚积而薄发.md</a>

                </li>
                <li>

                    
                    <a href="09&#32;JDK&#32;内置命令行工具：工欲善其事，必先利其器.md">09 JDK 内置命令行工具：工欲善其事，必先利其器.md</a>

                </li>
                <li>

                    
                    <a href="10&#32;JDK&#32;内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md">10 JDK 内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md</a>

                </li>
                <li>

                    
                    <a href="11&#32;JDWP&#32;简介：十步杀一人，千里不留行.md">11 JDWP 简介：十步杀一人，千里不留行.md</a>

                </li>
                <li>

                    
                    <a href="12&#32;JMX&#32;与相关工具：山高月小，水落石出.md">12 JMX 与相关工具：山高月小，水落石出.md</a>

                </li>
                <li>

                    
                    <a href="13&#32;常见的&#32;GC&#32;算法（GC&#32;的背景与原理）.md">13 常见的 GC 算法（GC 的背景与原理）.md</a>

                </li>
                <li>

                    
                    <a href="14&#32;常见的&#32;GC&#32;算法（ParallelCMSG1）.md">14 常见的 GC 算法（ParallelCMSG1）.md</a>

                </li>
                <li>

                    
                    <a href="15&#32;Java11&#32;ZGC&#32;和&#32;Java12&#32;Shenandoah&#32;介绍：苟日新、日日新、又日新.md">15 Java11 ZGC 和 Java12 Shenandoah 介绍：苟日新、日日新、又日新.md</a>

                </li>
                <li>

                    
                    <a href="16&#32;Oracle&#32;GraalVM&#32;介绍：会当凌绝顶、一览众山小.md">16 Oracle GraalVM 介绍：会当凌绝顶、一览众山小.md</a>

                </li>
                <li>

                    
                    <a href="17&#32;GC&#32;日志解读与分析（基础配置）.md">17 GC 日志解读与分析（基础配置）.md</a>

                </li>
                <li>

                    
                    <a href="18&#32;GC&#32;日志解读与分析（实例分析上篇）.md">18 GC 日志解读与分析（实例分析上篇）.md</a>

                </li>
                <li>

                    
                    <a href="19&#32;GC&#32;日志解读与分析（实例分析中篇）.md">19 GC 日志解读与分析（实例分析中篇）.md</a>

                </li>
                <li>

                    
                    <a href="20&#32;GC&#32;日志解读与分析（实例分析下篇）.md">20 GC 日志解读与分析（实例分析下篇）.md</a>

                </li>
                <li>

                    
                    <a href="21&#32;GC&#32;日志解读与分析（番外篇可视化工具）.md">21 GC 日志解读与分析（番外篇可视化工具）.md</a>

                </li>
                <li>

                    
                    <a href="22&#32;JVM&#32;的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md">22 JVM 的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md</a>

                </li>
                <li>

                    
                    <a href="23&#32;内存分析与相关工具上篇（内存布局与分析工具）.md">23 内存分析与相关工具上篇（内存布局与分析工具）.md</a>

                </li>
                <li>

                    
                    <a href="24&#32;内存分析与相关工具下篇（常见问题分析）.md">24 内存分析与相关工具下篇（常见问题分析）.md</a>

                </li>
                <li>

                    <a class="current-tab" href="25&#32;FastThread&#32;相关的工具介绍：欲穷千里目，更上一层楼.md">25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼.md</a>
                    

                </li>
                <li>

                    
                    <a href="26&#32;面临复杂问题时的几个高级工具：它山之石，可以攻玉.md">26 面临复杂问题时的几个高级工具：它山之石，可以攻玉.md</a>

                </li>
                <li>

                    
                    <a href="27&#32;JVM&#32;问题排查分析上篇（调优经验）.md">27 JVM 问题排查分析上篇（调优经验）.md</a>

                </li>
                <li>

                    
                    <a href="28&#32;JVM&#32;问题排查分析下篇（案例实战）.md">28 JVM 问题排查分析下篇（案例实战）.md</a>

                </li>
                <li>

                    
                    <a href="29&#32;GC&#32;疑难情况问题排查与分析（上篇）.md">29 GC 疑难情况问题排查与分析（上篇）.md</a>

                </li>
                <li>

                    
                    <a href="30&#32;GC&#32;疑难情况问题排查与分析（下篇）.md">30 GC 疑难情况问题排查与分析（下篇）.md</a>

                </li>
                <li>

                    
                    <a href="31&#32;JVM&#32;相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md">31 JVM 相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md</a>

                </li>
                <li>

                    
                    <a href="32&#32;应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md">32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md</a>

                </li>
            </ul>

        </div>
    </div>

    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
        <div class="sidebar-toggle-inner"></div>
    </div>

    <script>
        function add_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.add('show')
        }

        function remove_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.remove('show')
        }

        function sidebar_toggle() {
            let sidebar_toggle = document.querySelector('.sidebar-toggle')
            let sidebar = document.querySelector('.book-sidebar')
            let content = document.querySelector('.off-canvas-content')
            if (sidebar_toggle.classList.contains('extend')) { // show
                sidebar_toggle.classList.remove('extend')
                sidebar.classList.remove('hide')
                content.classList.remove('extend')
            } else { // hide
                sidebar_toggle.classList.add('extend')
                sidebar.classList.add('hide')
                content.classList.add('extend')
            }
        }
    </script>

    <div class="off-canvas-content">
        <div class="columns">
            <div class="column col-12 col-lg-12">
                <div class="book-navbar">
                    <!-- For Responsive Layout -->
                    <header class="navbar">
                        <section class="navbar-section">
                            <a onclick="open_sidebar()">
                                <i class="icon icon-menu"></i>
                            </a>
                        </section>
                    </header>
                </div>
                <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                    <div class="book-post">
                        <p id="tip" align="center"></p>
                        <div><h1>25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼</h1>
<h3>FastThread 简介</h3>
<p>在前面的章节里，我们知道了可以打印出来 JVM 的所有线程信息，然后进行分析。然而所有的线程信息都很长，看起来又差不多，每次去看都让人头大。</p>
<p>所以，每当我去分析线程都在想，要是有工具能帮我把一般情况汇总，并自动帮我分析分析 JVM 线程情况就好了。这里要介绍的 FastThread 就是这么一款工具。</p>
<blockquote>
<p>FastThread 是一款线程转储(Thread Dump)分析工具，官网地址为：<a href="http://fastthread.io/">http://fastthread.io/</a> 。</p>
<p>这款工具由 <a href="https://tier1app.com/">tier1app 公司</a> 开发和支持，这家公司现在主要提供 3 款 JVM 分析工具，除了 FastThread 还有：</p>
<ul>
<li>GCEasy，访问地址：<a href="https://gceasy.io/">https://gceasy.io/</a>，详情请参考前面的文章 [《GC 日志解读与分析（番外篇可视化工具）》]。</li>
<li>HeapHero，官网地址：<a href="https://heaphero.io/">https://heaphero.io/</a>，顾名思义，这是一款 Heap Dump 分析工具。</li>
</ul>
</blockquote>
<p>FastThread 工具可用来分析和定位问题，功能特征包括：</p>
<ul>
<li>通用线程转储分析，FastThread 是一款通用的线程转储分析工具，可以通过 JVM 导出的线程转储，来进行根本原因排查分析（RCA，root cause analysis）。</li>
<li>提供在线分析功能，因为线程转储一般不会太大，所以只需上传我们导出的线程转储文件即可快速查看分析报告，而不需要在本地计算机下载和安装。使用非常方便。</li>
<li>提供直观的线程分析视图，通过仪表盘等形式的图形展示，使用起来既简单又容易理解。并对各种线程状态进行分类，比如阻塞、运行、定时等待、等待，以及重复的堆栈跟踪。通过这款工具，可以快速方便地解决可扩展性、性能问题和可用性问题。</li>
<li>支持 REST 方式的 API 接口调用，FastThread 是业界第一款支持 API 方式的线程转储分析工具。通过 API 接口，我们就可以通过脚本或者程序实现自动化分析，适用于进行批量的操作。</li>
<li>支持核心转储分析（Core Dump Analysis），Java 核心转储包括很多信息，但格式非常难以理解和解析。FastThread 可以分析 Java 核心转储文件，并以图形方式提供精确的信息。</li>
<li>分析 hs_err_pid 文件，进程崩溃（crashes）或致命错误(fatal error）会导致JVM异常终止。这时候 JVM 会自动生成 hs_err_pid 文件。这个文件中包含大量的信息，可以用 FastThread 来帮助我们进行分析。</li>
</ul>
<blockquote>
<p>顺便说一句，JVM 的线程转储不只是 Java 语言有，其他语言也是支持的，例如 Scala、Jython、JRuby 等等。</p>
</blockquote>
<p>通过 FastThread 官方网站在线进行线程堆栈分析是“免费”的，下面我们通过示例程序来演示这款工具的使用。</p>
<h3>示例程序与线程 Dump</h3>
<p>基于前面《JVM 的线程堆栈数据分析》章节中的示例代码，我们简单修改一下，用来模拟死锁和线程等待的状态。</p>
<p>示例程序如下：</p>
<pre><code class="language-java">package demo.jvm0207;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
public class DeadLockSample2 {
    public static void main(String[] args) throws Exception {
        DeadLockTask deadLockTask = new DeadLockTask();
        // 多线程模拟死锁
        new Thread(deadLockTask).start();
        new Thread(deadLockTask).start();
        // 等待状态
        Thread wt = new WaitedThread();
        wt.start();
        // 当前线程等待另一个线程来汇合
        wt.join();
    }

    private static class WaitedThread extends Thread {
        @Override
        public void run() {
            synchronized (DeadLockSample2.class) {
                try {
                    DeadLockSample2.class.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // 简单的死锁; 分别锁2个对象
    private static class DeadLockTask implements Runnable {
        private Object lockA = new Object();
        private Object lockB = new Object();
        private AtomicBoolean flag = new AtomicBoolean(false);
        public void run() {
            try {
                if (flag.compareAndSet(false, true)) {
                    synchronized (lockA) {
                        TimeUnit.SECONDS.sleep(2);
                        synchronized (lockB) {
                            System.out.println(&quot;死锁内部代码&quot;);
                        }
                    }
                } else {
                    synchronized (lockB) {
                        TimeUnit.SECONDS.sleep(2);
                        synchronized (lockA) {
                            System.out.println(&quot;死锁内部代码&quot;);
                        }
                    }
                }
            } catch (Exception e) {
            }
        }
    }
}

</code></pre>
<p>我们启动程序，会发现系统卡住不动。</p>
<p>然后我们可以用各种工具来探测和检查线程状态，如果有不了解的同学，可以参考前面的 《[JVM 的线程堆栈数据分析]》章节。</p>
<p>线程转储快照（Thread Dump）可用来辅助诊断 CPU 高负载、死锁、内存异常、系统响应时间长等问题。</p>
<p>所以我们需要先获取对应的 Thread Dump 文件：</p>
<pre><code class="language-shell"># 查看本地 JVM 进程信息
jps -v
#  直接打印线程快照
jstack -l 51399
#  将线程快照信息保存到文件
jstack -l 51399 &gt; 51399.thread.dump.txt

</code></pre>
<p>jstack 工具得到的线程转储信息大致如下所示：</p>
<pre><code class="language-java">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.162-b12 mixed mode):

&quot;Thread-2&quot; #15 prio=5 os_prio=31 tid=0x00007fb3ee805000 nid=0x5a03 in Object.wait() [0x000070000475d000]
   java.lang.Thread.State: WAITING (on object monitor)
 at java.lang.Object.wait(Native Method)
 - waiting on &lt;0x000000076abee388&gt; (a java.lang.Class for demo.jvm0207.DeadLockSample2)
 at java.lang.Object.wait(Object.java:502)
 at demo.jvm0207.DeadLockSample2$WaitedThread.run(DeadLockSample2.java:25)
 - locked &lt;0x000000076abee388&gt; (a java.lang.Class for demo.jvm0207.DeadLockSample2)

   Locked ownable synchronizers:
 - None

&quot;Thread-1&quot; #14 prio=5 os_prio=31 tid=0x00007fb3ed05d800 nid=0x5903 waiting for monitor entry [0x000070000465a000]
   java.lang.Thread.State: BLOCKED (on object monitor)
 at demo.jvm0207.DeadLockSample2$DeadLockTask.run(DeadLockSample2.java:52)
 - waiting to lock &lt;0x000000076abf7338&gt; (a java.lang.Object)
 - locked &lt;0x000000076abf7348&gt; (a java.lang.Object)
 at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
 - None

&quot;Thread-0&quot; #13 prio=5 os_prio=31 tid=0x00007fb3ef8c1000 nid=0xa703 waiting for monitor entry [0x0000700004557000]
   java.lang.Thread.State: BLOCKED (on object monitor)
 at demo.jvm0207.DeadLockSample2$DeadLockTask.run(DeadLockSample2.java:45)
 - waiting to lock &lt;0x000000076abf7348&gt; (a java.lang.Object)
 - locked &lt;0x000000076abf7338&gt; (a java.lang.Object)
 at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
 - None

&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fb3ee006000 nid=0x2603 in Object.wait() [0x0000700002f15000]
   java.lang.Thread.State: WAITING (on object monitor)
 at java.lang.Object.wait(Native Method)
 - waiting on &lt;0x000000076abf7cf8&gt; (a demo.jvm0207.DeadLockSample2$WaitedThread)
 at java.lang.Thread.join(Thread.java:1252)
 - locked &lt;0x000000076abf7cf8&gt; (a demo.jvm0207.DeadLockSample2$WaitedThread)
 at java.lang.Thread.join(Thread.java:1326)
 at demo.jvm0207.DeadLockSample2.main(DeadLockSample2.java:17)

   Locked ownable synchronizers:
 - None

JNI global references: 1358

Found one Java-level deadlock:
=============================
&quot;Thread-1&quot;:
  waiting to lock monitor 0x00007fb3ee01f698 (object 0x000000076abf7338，a java.lang.Object)，
  which is held by &quot;Thread-0&quot;
&quot;Thread-0&quot;:
  waiting to lock monitor 0x00007fb3ee01f7f8 (object 0x000000076abf7348，a java.lang.Object)，
  which is held by &quot;Thread-1&quot;

Java stack information for the threads listed above:
===================================================
&quot;Thread-1&quot;:
 at demo.jvm0207.DeadLockSample2$DeadLockTask.run(DeadLockSample2.java:52)
 - waiting to lock &lt;0x000000076abf7338&gt; (a java.lang.Object)
 - locked &lt;0x000000076abf7348&gt; (a java.lang.Object)
 at java.lang.Thread.run(Thread.java:748)
&quot;Thread-0&quot;:
 at demo.jvm0207.DeadLockSample2$DeadLockTask.run(DeadLockSample2.java:45)
 - waiting to lock &lt;0x000000076abf7348&gt; (a java.lang.Object)
 - locked &lt;0x000000076abf7338&gt; (a java.lang.Object)
 at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.

</code></pre>
<p>工具自动找到了死锁，另外几个处于等待状态的线程也标识了出来。当然，上面省略了其他线程的信息，例如：</p>
<pre><code class="language-java">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.162-b12 mixed mode):
&quot;Thread-2&quot; #15 ... in Object.wait()
   java.lang.Thread.State: WAITING (on object monitor)
&quot;Thread-1&quot; #14 ... waiting for monitor entry
   java.lang.Thread.State: BLOCKED (on object monitor)
&quot;Thread-0&quot; #13 ... waiting for monitor entry
   java.lang.Thread.State: BLOCKED (on object monitor)
&quot;Service Thread&quot; #12 ... daemon prio=9 ... runnable
   java.lang.Thread.State: RUNNABLE
&quot;C2 CompilerThread2&quot; #10 daemon ... waiting on condition
   java.lang.Thread.State: RUNNABLE
&quot;Signal Dispatcher&quot; #4 daemon ... runnable
   java.lang.Thread.State: RUNNABLE
&quot;Finalizer&quot; #3 daemon ... in Object.wait()
   java.lang.Thread.State: WAITING (on object monitor)
&quot;Reference Handler&quot; #2 daemon ... in Object.wait()
   java.lang.Thread.State: WAITING (on object monitor)
&quot;main&quot; #1 ... in Object.wait()
   java.lang.Thread.State: WAITING (on object monitor)

&quot;VM Thread&quot; ... runnable
&quot;GC task thread#0 (ParallelGC)&quot; ... runnable
&quot;GC task thread#1 (ParallelGC)&quot; ... runnable
&quot;GC task thread#2 (ParallelGC)&quot; ... runnable
&quot;GC task thread#3 (ParallelGC)&quot; ... runnable
&quot;GC task thread#4 (ParallelGC)&quot; ... runnable
&quot;GC task thread#5 (ParallelGC)&quot; ... runnable
&quot;GC task thread#6 (ParallelGC)&quot; ... runnable
&quot;GC task thread#7 (ParallelGC)&quot; ... runnable
&quot;VM Periodic Task Thread&quot; ... waiting on condition

</code></pre>
<p>获取到了线程快照信息之后，下面我们来看看怎么使用 FastThread 分析工具。</p>
<h3>FastThread 使用示例</h3>
<p>打开官网首页：<a href="http://fastthread.io/">http://fastthread.io/</a>。</p>
<h4><strong>文件上传方式</strong></h4>
<p><img src="assets/98bd8e60-7504-11ea-92e8-fb0928480567" alt="img" /></p>
<p>选择文件并上传，然后鼠标点击“分析”（Analyze）按钮即可。</p>
<h4><strong>上传文本方式</strong></h4>
<p><img src="assets/a5e18240-7504-11ea-94a5-05a63ed48ac3" alt="img" /></p>
<p>两种方式步骤都差不多，选择 RAW 方式上传文本字符串，然后点击分析按钮。</p>
<h4><strong>分析结果页面</strong></h4>
<p>等待片刻，自动跳转到分析结果页面。</p>
<p><img src="assets/bb219280-7504-11ea-9628-dd9a4bfcf1d2" alt="6843295.png" /></p>
<p>这里可以看到基本信息，以及右边的一些链接：</p>
<ul>
<li>分享报告，可以很方便地把报告结果发送给其他小伙伴。</li>
</ul>
<h4><strong>线程数汇总</strong></h4>
<p>把页面往下拉，可以看到线程数量汇总报告。</p>
<p><img src="assets/c6db4800-7504-11ea-b77f-634b57f46967" alt="6864312.png" /></p>
<p>从这个报告中可以很直观地看到，线程总数为 26，其中 19 个运行状态线程，5 个等待状态的线程，2 个阻塞状态线程。</p>
<p>右边还给了一个饼图，展示各种状态所占的比例。</p>
<h4><strong>线程组分析</strong></h4>
<p>接着是将线程按照名称自动分组。</p>
<p><img src="assets/ef8a2af0-7504-11ea-9dae-5d0db1c26be7" alt="6898070.png" /></p>
<p>这里就看到线程命名的好处了吧！如果我们的线程池统一命名，那么相关资源池的使用情况就很直观。</p>
<blockquote>
<p>所以在代码里使用线程池的时候，统一添加线程名称就是一个好的习惯！</p>
</blockquote>
<h4><strong>守护线程分析</strong></h4>
<p>接下来是守护线程分析：</p>
<p><img src="assets/08d3b580-7505-11ea-9628-dd9a4bfcf1d2" alt="6923926.png" /></p>
<p>这里可以看到守护线程与前台线程的统计信息。</p>
<h4><strong>死锁情况检测</strong></h4>
<p>当然，也少不了死锁分析：</p>
<p><img src="assets/f4af8010-7505-11ea-a691-fda85882301c" alt="6948610.png" /></p>
<p>可以看到，各个工具得出的死锁检测结果都差不多。并不难分析，其中给出了线程名称，以及方法调用栈信息，等待的是哪个锁。</p>
<h4><strong>线程调用栈情况</strong></h4>
<p>以及线程调用情况：</p>
<p><img src="assets/ec4f55d0-7505-11ea-bb80-67799d8258e1" alt="7008839.png" /></p>
<p>后面是这些线程的详情：</p>
<p><img src="assets/e5ca7b40-7505-11ea-a8c0-4fdc777140d0" alt="7058206.png" /></p>
<p>这块信息只是将相关的方法调用栈展示出来。</p>
<h4><strong>热点方法统计</strong></h4>
<p>热点方法是一个需要注意的重点，调用的越多，说明这一块可能是系统的性能瓶颈。</p>
<p><img src="assets/d789f3d0-7505-11ea-965e-2b5335ba3591" alt="7104053.png" /></p>
<p>这里展示了此次快照中正在执行的方法。如果只看热点方法抽样的话，更精确的工具是 JDK 内置的 hprof。</p>
<p>但如果有很多方法阻塞或等待，则线程快照中展示的热点方法位置可以快速确定问题出现的代码行。</p>
<h4><strong>CPU 消耗信息</strong></h4>
<p><img src="assets/cc8891d0-7505-11ea-b77f-634b57f46967" alt="img" /></p>
<p>这里的提示信息不太明显，但给出了一些学习资源，这些资源请参考本文末尾给出的博客链接地址。</p>
<h4><strong>GC 线程信息</strong></h4>
<p><img src="assets/c466a910-7505-11ea-94a5-05a63ed48ac3" alt="img" /></p>
<p>这里看到 GC 线程数是 8 个，这个值跟具体的 CPU 内核数量相差不大就算是正常的。</p>
<p>GC 线程数如果太多或者太少，会造成很多问题，我们在后面的章节中通过案例进行讲解。</p>
<h4><strong>线程栈深度</strong></h4>
<p><img src="assets/b3d1aa50-7505-11ea-a8c0-4fdc777140d0" alt="7277060.png" /></p>
<p>这里都小于10，说明堆栈都不深。</p>
<h4><strong>复杂死锁检测</strong></h4>
<p>接下来是复杂死锁检测和 Finalizer 线程的信息。</p>
<p><img src="assets/a9ec3fa0-7505-11ea-965e-2b5335ba3591" alt="7295147.png" /></p>
<p>简单死锁是指两个线程之间互相死等资源锁。那么什么复杂死锁呢？ 这个问题留给同学们自己搜索。</p>
<h4><strong>火焰图</strong></h4>
<p><img src="assets/a0e32b30-7505-11ea-8fb8-ffe43c2e987a" alt="7336167.png" /></p>
<p>火焰图挺有趣，将所有线程调用栈汇总到一张图片中。</p>
<h4><strong>调用栈树</strong></h4>
<p>如果我们把所有的调用栈合并到一起，整体来看呢？</p>
<p><img src="assets/7502de70-7505-11ea-a8c0-4fdc777140d0" alt="7358293.png" /></p>
<p>树形结构在有些时候也很有用，比如大量线程都在执行类似的调用栈路径时。</p>
<p>以上这些信息，都有助于我们去分析和排查 JVM 问题，而图形工具相对于命令行工具的好处是直观、方便、快速，帮我们省去过滤一些不必要的干扰信息的时间。</p>
<h3>参考链接</h3>
<ul>
<li><a href="https://www.jianshu.com/p/433dfb0f7879">8 个抓取 Java Thread Dumps 的方式</a></li>
<li><a href="https://blog.fastthread.io/2016/06/06/how-to-take-thread-dumps-7-options/">Thread Dump 选项</a></li>
<li><a href="https://blog.fastthread.io/">FastThread 官方博客</a></li>
</ul>
</div>
                    </div>
                    <div>
                        <div style="float: left">
                            <a href="24&#32;内存分析与相关工具下篇（常见问题分析）.md">上一页</a>
                        </div>
                        <div style="float: right">
                            <a href="26&#32;面临复杂问题时的几个高级工具：它山之石，可以攻玉.md">下一页</a>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v64f9daad31f64f81be21cbef6184a5e31634941392597" integrity="sha512-gV/bogrUTVP2N3IzTDKzgP0Js1gg4fbwtYB6ftgLbKQu/V8yH2+lrKCfKHelh4SO3DPzKj4/glTO+tNJGDnb0A==" data-cf-beacon='{"rayId":"6b43411a0a1a70ac","version":"2021.11.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/&quot;&#32;+&#32;cookie&#32;+&#32;&quot;'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }
</script>

</html>
