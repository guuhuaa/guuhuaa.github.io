<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>12 JMX 与相关工具：山高月小，水落石出.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
    </head>

<body>

<div class="book-container">
    <div class="book-sidebar">
        <div class="book-brand">
            <a href="../../index.html">
                <img src="../../static/favicon.png">
                <span>技术文章摘抄</span>
            </a>
        </div>
        <div class="book-menu uncollapsible">
            <ul class="uncollapsible">
                <li><a href="../../index.html" class="current-tab">首页</a></li>
            </ul>

            <ul class="uncollapsible">
                <li><a href="../index.html">上一级</a></li>
            </ul>

            <ul class="uncollapsible">
                <li>

                    
                    <a href="01&#32;阅读此专栏的正确姿势.md">01 阅读此专栏的正确姿势.md</a>

                </li>
                <li>

                    
                    <a href="02&#32;环境准备：千里之行，始于足下.md">02 环境准备：千里之行，始于足下.md</a>

                </li>
                <li>

                    
                    <a href="03&#32;常用性能指标：没有量化，就没有改进.md">03 常用性能指标：没有量化，就没有改进.md</a>

                </li>
                <li>

                    
                    <a href="04&#32;JVM&#32;基础知识：不积跬步，无以至千里.md">04 JVM 基础知识：不积跬步，无以至千里.md</a>

                </li>
                <li>

                    
                    <a href="05&#32;Java&#32;字节码技术：不积细流，无以成江河.md">05 Java 字节码技术：不积细流，无以成江河.md</a>

                </li>
                <li>

                    
                    <a href="06&#32;Java&#32;类加载器：山不辞土，故能成其高.md">06 Java 类加载器：山不辞土，故能成其高.md</a>

                </li>
                <li>

                    
                    <a href="07&#32;Java&#32;内存模型：海不辞水，故能成其深.md">07 Java 内存模型：海不辞水，故能成其深.md</a>

                </li>
                <li>

                    
                    <a href="08&#32;JVM&#32;启动参数详解：博观而约取、厚积而薄发.md">08 JVM 启动参数详解：博观而约取、厚积而薄发.md</a>

                </li>
                <li>

                    
                    <a href="09&#32;JDK&#32;内置命令行工具：工欲善其事，必先利其器.md">09 JDK 内置命令行工具：工欲善其事，必先利其器.md</a>

                </li>
                <li>

                    
                    <a href="10&#32;JDK&#32;内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md">10 JDK 内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md</a>

                </li>
                <li>

                    
                    <a href="11&#32;JDWP&#32;简介：十步杀一人，千里不留行.md">11 JDWP 简介：十步杀一人，千里不留行.md</a>

                </li>
                <li>

                    <a class="current-tab" href="12&#32;JMX&#32;与相关工具：山高月小，水落石出.md">12 JMX 与相关工具：山高月小，水落石出.md</a>
                    

                </li>
                <li>

                    
                    <a href="13&#32;常见的&#32;GC&#32;算法（GC&#32;的背景与原理）.md">13 常见的 GC 算法（GC 的背景与原理）.md</a>

                </li>
                <li>

                    
                    <a href="14&#32;常见的&#32;GC&#32;算法（ParallelCMSG1）.md">14 常见的 GC 算法（ParallelCMSG1）.md</a>

                </li>
                <li>

                    
                    <a href="15&#32;Java11&#32;ZGC&#32;和&#32;Java12&#32;Shenandoah&#32;介绍：苟日新、日日新、又日新.md">15 Java11 ZGC 和 Java12 Shenandoah 介绍：苟日新、日日新、又日新.md</a>

                </li>
                <li>

                    
                    <a href="16&#32;Oracle&#32;GraalVM&#32;介绍：会当凌绝顶、一览众山小.md">16 Oracle GraalVM 介绍：会当凌绝顶、一览众山小.md</a>

                </li>
                <li>

                    
                    <a href="17&#32;GC&#32;日志解读与分析（基础配置）.md">17 GC 日志解读与分析（基础配置）.md</a>

                </li>
                <li>

                    
                    <a href="18&#32;GC&#32;日志解读与分析（实例分析上篇）.md">18 GC 日志解读与分析（实例分析上篇）.md</a>

                </li>
                <li>

                    
                    <a href="19&#32;GC&#32;日志解读与分析（实例分析中篇）.md">19 GC 日志解读与分析（实例分析中篇）.md</a>

                </li>
                <li>

                    
                    <a href="20&#32;GC&#32;日志解读与分析（实例分析下篇）.md">20 GC 日志解读与分析（实例分析下篇）.md</a>

                </li>
                <li>

                    
                    <a href="21&#32;GC&#32;日志解读与分析（番外篇可视化工具）.md">21 GC 日志解读与分析（番外篇可视化工具）.md</a>

                </li>
                <li>

                    
                    <a href="22&#32;JVM&#32;的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md">22 JVM 的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md</a>

                </li>
                <li>

                    
                    <a href="23&#32;内存分析与相关工具上篇（内存布局与分析工具）.md">23 内存分析与相关工具上篇（内存布局与分析工具）.md</a>

                </li>
                <li>

                    
                    <a href="24&#32;内存分析与相关工具下篇（常见问题分析）.md">24 内存分析与相关工具下篇（常见问题分析）.md</a>

                </li>
                <li>

                    
                    <a href="25&#32;FastThread&#32;相关的工具介绍：欲穷千里目，更上一层楼.md">25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼.md</a>

                </li>
                <li>

                    
                    <a href="26&#32;面临复杂问题时的几个高级工具：它山之石，可以攻玉.md">26 面临复杂问题时的几个高级工具：它山之石，可以攻玉.md</a>

                </li>
                <li>

                    
                    <a href="27&#32;JVM&#32;问题排查分析上篇（调优经验）.md">27 JVM 问题排查分析上篇（调优经验）.md</a>

                </li>
                <li>

                    
                    <a href="28&#32;JVM&#32;问题排查分析下篇（案例实战）.md">28 JVM 问题排查分析下篇（案例实战）.md</a>

                </li>
                <li>

                    
                    <a href="29&#32;GC&#32;疑难情况问题排查与分析（上篇）.md">29 GC 疑难情况问题排查与分析（上篇）.md</a>

                </li>
                <li>

                    
                    <a href="30&#32;GC&#32;疑难情况问题排查与分析（下篇）.md">30 GC 疑难情况问题排查与分析（下篇）.md</a>

                </li>
                <li>

                    
                    <a href="31&#32;JVM&#32;相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md">31 JVM 相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md</a>

                </li>
                <li>

                    
                    <a href="32&#32;应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md">32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md</a>

                </li>
            </ul>

        </div>
    </div>

    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
        <div class="sidebar-toggle-inner"></div>
    </div>

    <script>
        function add_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.add('show')
        }

        function remove_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.remove('show')
        }

        function sidebar_toggle() {
            let sidebar_toggle = document.querySelector('.sidebar-toggle')
            let sidebar = document.querySelector('.book-sidebar')
            let content = document.querySelector('.off-canvas-content')
            if (sidebar_toggle.classList.contains('extend')) { // show
                sidebar_toggle.classList.remove('extend')
                sidebar.classList.remove('hide')
                content.classList.remove('extend')
            } else { // hide
                sidebar_toggle.classList.add('extend')
                sidebar.classList.add('hide')
                content.classList.add('extend')
            }
        }
    </script>

    <div class="off-canvas-content">
        <div class="columns">
            <div class="column col-12 col-lg-12">
                <div class="book-navbar">
                    <!-- For Responsive Layout -->
                    <header class="navbar">
                        <section class="navbar-section">
                            <a onclick="open_sidebar()">
                                <i class="icon icon-menu"></i>
                            </a>
                        </section>
                    </header>
                </div>
                <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                    <div class="book-post">
                        <p id="tip" align="center"></p>
                        <div><h1>12 JMX 与相关工具：山高月小，水落石出</h1>
<p>Java 平台提供了全面的 JVM 监控和管理措施。</p>
<p>在 Java SE 5 之前，虽然 JVM 提供了一些底层的 API，比如 JVMPI 和 JVMTI，但这些 API 都是面向 C 语言的，需要通过 JNI 等方式才能调用，想要监控 JVM 和系统资源非常不方便。</p>
<p>Java SE 5.0 版本引入了 JMX 技术（Java Management Extensions，Java 管理扩展），JMX 技术的前身是“JSR3:Java Management Extensions”，以及“JSR 160:JMX Remote API”。</p>
<p>JMX 是用于监控和管理 JVM 资源（包括应用程序、设备、服务和 JVM）的一组标准 API。</p>
<p>通过这些 API 接口，可以对外暴露 JVM 和宿主机的一些信息，甚至支持远程动态调整某些运行时参数。</p>
<p>JMX 技术让我们在 JDK 中开发自检程序成为可能，同时也提供了很多轻量级的 API 来监测 JVM 状态和运行中对象/线程状态，从而提高了 Java 语言自身的管理监测能力。</p>
<p>客户端使用 JMX 主要通过两种方式：</p>
<ul>
<li>程序代码手动获取 MXBean；</li>
<li>通过网络远程获取 MBean。</li>
</ul>
<p>从 JVM 运行时获取 GC 行为数据，最简单的办法是使用标准 JMX API 接口。JMX 也是获取 JVM 内部运行时状态信息 的标准 API。可以编写程序代码，通过 JMX API 来访问本程序所在的 JVM，也可以通过 JMX 客户端执行（远程）访问。MXBean 可用于监控和管理 JVM，每个 MXBean 都封装了一部分功能。</p>
<p>如果用通俗的话来讲，就是我们可以在 JVM 这个机构内部搞一个“政务信息公开系统”，这个东西就可以看做是 MBeanServer，然后系统默认有很多信息，比如 JVM 的基本信息、内存和 GC 的信息等，可以放到这个系统来公开。应用程序里的其他 Java 代码也可以自己定义一些 MBean，然后把这些自己想要公开的信息挂到这个系统里来。这个时候，就不管是本 JVM 内部，还是其他的 Java 应用程序，都可以访问到这个 MBeanServer 上的所有公开信息，也就是 MBean 的属性，甚至可以直接调用 MBean 提供的方法反过来影响系统。</p>
<h2>获取当前 JVM 的 MXBean 信息</h2>
<p>JDK 默认提供的 MXBean 相关类，主要位于 rt.jar 文件的 java.lang.management 包中。获取 JVM 中 MXBean 信息的代码示例如下：</p>
<pre><code class="language-java">package jvm.chapter11;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.*;
import java.lang.management.*;
import java.util.*;

public class MXBeanTest {
    public static void main(String[] args) {
        Map&lt;String, Object&gt; beansMap = loadMXBeanMap();
        String jsonString = toJSON(beansMap);
        System.out.println(jsonString);
    }
    public static Map&lt;String, Object&gt; loadMXBeanMap() {
        // import java.lang.management.*
        // 1. 操作系统信息
        OperatingSystemMXBean operatingSystemMXBean =
                ManagementFactory.getOperatingSystemMXBean();
        // 2. 运行时
        RuntimeMXBean runtimeMXBean =
                ManagementFactory.getRuntimeMXBean();
        // 3.1 JVM 内存信息
        MemoryMXBean memoryMXBean =
                ManagementFactory.getMemoryMXBean();
        // 3.2 JVM 内存池-列表
        List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans =
                ManagementFactory.getMemoryPoolMXBeans();
        // 3.3 内存管理器-列表
        List&lt;MemoryManagerMXBean&gt; memoryManagerMXBeans =
                ManagementFactory.getMemoryManagerMXBeans();
        // 4. class 加载统计信息
        ClassLoadingMXBean classLoadingMXBean =
                ManagementFactory.getClassLoadingMXBean();
        // 5. 编译统计信息
        CompilationMXBean compilationMXBean =
                ManagementFactory.getCompilationMXBean();
        // 6. 线程
        ThreadMXBean threadMXBean =
                ManagementFactory.getThreadMXBean();
        // 7. GC
        List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans =
                ManagementFactory.getGarbageCollectorMXBeans();
        // 8. 获取平台日志 MXBean
        PlatformLoggingMXBean platformLoggingMXBean =
                ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class);
        //
        Map&lt;String, Object&gt; beansMap = new HashMap&lt;String, Object&gt;();
        //
        beansMap.put(&quot;operatingSystemMXBean&quot;, operatingSystemMXBean);
        beansMap.put(&quot;runtimeMXBean&quot;, runtimeMXBean);
        beansMap.put(&quot;memoryMXBean&quot;, memoryMXBean);
        beansMap.put(&quot;memoryPoolMXBeans&quot;, memoryPoolMXBeans);
        beansMap.put(&quot;memoryManagerMXBeans&quot;, memoryManagerMXBeans);
        beansMap.put(&quot;classLoadingMXBean&quot;, classLoadingMXBean);
        beansMap.put(&quot;compilationMXBean&quot;, compilationMXBean);
        beansMap.put(&quot;threadMXBean&quot;, threadMXBean);
        beansMap.put(&quot;garbageCollectorMXBeans&quot;, garbageCollectorMXBeans);
        beansMap.put(&quot;platformLoggingMXBean&quot;, platformLoggingMXBean);
        return beansMap;
    }

    public static String toJSON(Object obj) {
        // MemoryPoolMXBean 这些未设置的属性序列化时会报错
        SimplePropertyPreFilter filter = new SimplePropertyPreFilter();
        filter.getExcludes().add(&quot;collectionUsageThreshold&quot;);
        filter.getExcludes().add(&quot;collectionUsageThresholdCount&quot;);
        filter.getExcludes().add(&quot;collectionUsageThresholdExceeded&quot;);
        filter.getExcludes().add(&quot;usageThreshold&quot;);
        filter.getExcludes().add(&quot;usageThresholdCount&quot;);
        filter.getExcludes().add(&quot;usageThresholdExceeded&quot;);
        //
        String jsonString = JSON.toJSONString(obj, filter, 
                SerializerFeature.PrettyFormat);
        return jsonString;
    }
}

</code></pre>
<p>取得这些 MXBean 之后，就能采集到对应的 Java 运行时信息，定时上报给某个系统，那么一个简单的监控就创建了。</p>
<p>当然，这么简单的事情，肯定有现成的轮子啦。比如 Spring Boot Actuator，以及后面介绍的 Micrometer 等。各种监控服务提供的 Agent-lib 中也会通过类似的手段采集相应的数据。</p>
<p>如果想通过编程方式获取远程机器上的 MXBean，请参考：</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/mxbeans.html">Using the Platform MBean Server and Platform MXBeans</a></p>
</blockquote>
<h2>使用 JMX 工具远程连接</h2>
<p>最常见的 JMX 客户端是 JConsole 和 JVisualVM（可以安装各种插件，十分强大）。两个工具都是标准 JDK 的一部分，而且很容易使用. 如果使用的是 JDK 7u40 及更高版本，还可以使用另一个工具：Java Mission Control（JMC，大致翻译为 Java 控制中心）。</p>
<p>监控本地 JVM 并不需要额外配置，如果是远程监控，还可以在服务端部署 Jstatd 服务暴露部分信息给 JMX 客户端。</p>
<p>所有 JMX 客户端都是独立的程序，可以连接到目标 JVM 上。目标 JVM 可以在本机，也可以是远端 JVM。</p>
<p>想要支持 JMX 客户端连接服务端 JVM 实例，则 Java 启动脚本中需要加上相关的配置参数，示例如下：</p>
<pre><code class="language-shell">-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=10990
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false

</code></pre>
<p>如果服务器具有多张网卡（多个 IP），由于安全限制，必须明确指定 hostname， 一般是 IP。</p>
<pre><code class="language-shell">-Djava.rmi.server.hostname=47.57.227.67

</code></pre>
<p>这样启动之后，JMX 客户端（如 JConsole、JVisualVM、JMC）就可以通过 <code>&lt;IP:端口&gt;</code> 连接。(参考 JVisualVM 的示例）。</p>
<p>如这里对应的就类似于：47.57.227.67:10990。</p>
<blockquote>
<p>如果想要远程查看 VisualGC，则服务端需要开启 Jstatd 来支持，JVisualVM 先连 Jstatd 远程主机，接着在远程主机上点右键添加 JMX 连接。关于 JVisualVM 的使用，请参考前面的文章《JDK 内置图形界面工具》。</p>
</blockquote>
<p>以 JConsole 为例，我们看一下，连接到了远程 JVM 以后，在最后一个面板即可看到 MBean 信息。</p>
<p>例如，我们可以查看 JVM 的一些信息：</p>
<p><img src="assets/58f59680-2d68-11ea-a743-8137f2e46c91" alt="enter image description here" /></p>
<p>也可以直接调用方法，例如查看 VM 参数：</p>
<p><img src="assets/629d8300-2d68-11ea-a743-8137f2e46c91" alt="enter image description here" /></p>
<p>如果启动的进程是 Tomcat 或者是 Spring Boot 启动的嵌入式 Tomcat，那么我们还可以看到很多 Tomcat 的信息：</p>
<p><img src="assets/6bd52180-2d68-11ea-b8bc-595e31068820" alt="enter image description here" /></p>
<h2>JMX 的 MBean 创建和远程访问</h2>
<p>前面讲了在同一个 JVM 里获取 MBean，现在我们再来写一个更完整的例子：创建一个 MBean，然后远程访问它。</p>
<p>先定义一个 UserMBean 接口（必须以 MBean 作为后缀）：</p>
<pre><code class="language-java">package io.github.kimmking.jvmstudy.jmx;
public interface UserMBean {
    Long getUserId();
    String getUserName();
    void setUserId(Long userId);
    void setUserName(String userName);
}

</code></pre>
<p>然后实现它：</p>
<pre><code class="language-java">package io.github.kimmking.jvmstudy.jmx;
public class User implements UserMBean {
    Long userId = 12345678L;
    String userName = &quot;jvm-user&quot;;
    @Override
    public Long getUserId() {
        return userId;
    }

    @Override
    public String getUserName() {
        return userName;
    }

    @Override
    public void setUserId(Long userId) {
        this.userId = userId;
    }

    @Override
    public void setUserName(String userName) {
        this.userName = userName;
    }
}

</code></pre>
<p>最后实现一个类来启动 MBeanServer：</p>
<pre><code class="language-java">package io.github.kimmking.jvmstudy.jmx;

import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.ObjectName;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXConnectorServerFactory;
import javax.management.remote.JMXServiceURL;
import java.lang.management.ManagementFactory;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class UserJmxServer {

    public static void main(String[] args){

        MBeanServer server;
        User bean=new User();

        try {

            int rmiPort = 1099;
            String jmxServerName = &quot;TestJMXServer&quot;;

            Registry registry = LocateRegistry.createRegistry(rmiPort);
            server = MBeanServerFactory.createMBeanServer(&quot;user&quot;);

            ObjectName objectName = new ObjectName(&quot;user:name=User&quot;);
            server.registerMBean(bean, objectName);

            JMXServiceURL url = new JMXServiceURL(&quot;service:jmx:rmi:///jndi/rmi://localhost:1099/user&quot;);
            System.out.println(&quot;JMXServiceURL: &quot; + url.toString());
            JMXConnectorServer jmxConnServer = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);
            jmxConnServer.start();

        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

</code></pre>
<p>通过这几个代码我们可以看到，使用 MBean 机制，需要：</p>
<ul>
<li>先定义 MBean 接口；</li>
<li>实现这个接口；</li>
<li>然后把接口和类，注册到 MBeanServer，这里可以用 JVM 里的默认 MBeanServer，也可以自己创建一个新的 Server，这里为了简单，就使用了默认的。</li>
</ul>
<p>然后我们就可以使用客户端工具或者代码来访问 MBeanServer，查看和操作 MBean，由于 MBean 类似反射的机制（如果早期做过 Windows 平台的 COM 对象开发，就会发现是类似的），客户端不需要知道具体的 MBean 接口或者实现类，也能请求服务器端。</p>
<p>如果大家学习过 Apache Dubbo，就知道在 Dubbo 里消费端必须拿到服务提供者的服务接口，才能配置和调用，这里不同的地方就是客户端是不需要 MBean 接口的。</p>
<h3>JConsole 里查看自定义 MBean</h3>
<p>首先我们启动这个应用 UserJmxServer，接下来我们使用工具来查看和操作它。</p>
<p>打开 JConsole，在远程输入：</p>
<pre><code>service:jmx:rmi:///jndi/rmi://localhost:1099/user

</code></pre>
<p><img src="assets/7c66ebf0-2d68-11ea-b6a8-fbb27a899f8c" alt="enter image description here" /></p>
<p>查看 User 的属性：</p>
<p><img src="assets/84cfa1b0-2d68-11ea-8fee-9f496e85c50f" alt="enter image description here" /></p>
<p>直接修改 UserName 的值：</p>
<p><img src="assets/8cb2acb0-2d68-11ea-b6fe-19eaa05aac2e" alt="enter image description here" /></p>
<h3>使用 JMX 远程访问 MBean</h3>
<p>我们先使用 JMXUrl 来创建一个 MBeanServerConnection，连接到 MBeanServer，然后就可以通过 ObjectName，也可以看做是 MBean 的地址，像反射一样去拿服务器端 MBean 里的属性，或者调用 MBean 的方法。示例如下：</p>
<pre><code class="language-java">package io.github.kimmking.jvmstudy.jmx;

import javax.management.*;
import javax.management.remote.*;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Iterator;
import java.util.Set;

public class UserJmxClient {
    public static void main(String[] args){
        try {
            String surl = &quot;service:jmx:rmi:///jndi/rmi://localhost:1099/user&quot;;
            JMXServiceURL url = new JMXServiceURL(surl);
            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);
            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();

            System.out.println(&quot;Domains:---------------&quot;);
            String domains[] = mbsc.getDomains();
            for (int i = 0; i &lt; domains.length; i++) {
                System.out.println(&quot;\tDomain[&quot; + i + &quot;] = &quot; + domains[i]);
            }
            System.out.println(&quot;all ObjectName：---------------&quot;);
            Set&lt;ObjectInstance&gt; set = mbsc.queryMBeans(null, null);
            for (Iterator&lt;ObjectInstance&gt; it = set.iterator(); it.hasNext();) {
                ObjectInstance objectInstance = (ObjectInstance) it.next();
                System.out.println(&quot;\t&quot; + objectInstance.getObjectName() + &quot; =&gt; &quot; + objectInstance.getClassName());
            }
            System.out.println(&quot;user:name=User：---------------&quot;);
            ObjectName mbeanName = new ObjectName(&quot;user:name=User&quot;);
            MBeanInfo info = mbsc.getMBeanInfo(mbeanName);
            System.out.println(&quot;Class: &quot; + info.getClassName());
            if (info.getAttributes().length &gt; 0){
                for(MBeanAttributeInfo m : info.getAttributes())
                    System.out.println(&quot;\t ==&gt; Attriber：&quot; + m.getName());
            }
            if (info.getOperations().length &gt; 0){
                for(MBeanOperationInfo m : info.getOperations())
                    System.out.println(&quot;\t ==&gt; Operation：&quot; + m.getName());
            }

            System.out.println(&quot;Testing userName and userId .......&quot;);
            Object userNameObj = mbsc.getAttribute(mbeanName,&quot;UserName&quot;);
            System.out.println(&quot;\t ==&gt; userName：&quot; + userNameObj);
            Object userIdObj = mbsc.getAttribute(mbeanName,&quot;UserId&quot;);
            System.out.println(&quot;\t ==&gt; userId：&quot; + userIdObj);

            Attribute userNameAttr = new Attribute(&quot;UserName&quot;,&quot;kimmking&quot;);
            mbsc.setAttribute(mbeanName,userNameAttr);

            System.out.println(&quot;Modify UserName .......&quot;);

            userNameObj = mbsc.getAttribute(mbeanName,&quot;UserName&quot;);
            System.out.println(&quot;\t ==&gt; userName：&quot; + userNameObj);

            jmxc.close();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

</code></pre>
<p>直接运行，输出如下：</p>
<pre><code>Domains:---------------
 Domain[0] = JMImplementation
 Domain[1] = user
all ObjectName：---------------
 JMImplementation:type=MBeanServerDelegate =&gt; javax.management.MBeanServerDelegate
 user:name=User =&gt; io.github.kimmking.jvmstudy.jmx.User
user:name=User：---------------
Class: io.github.kimmking.jvmstudy.jmx.User
  ==&gt; Attriber：UserName
  ==&gt; Attriber：UserId
Testing userName and userId .......
  ==&gt; userName：jvm-user
  ==&gt; userId：12345678
Modify UserName .......
  ==&gt; userName：kimmking

</code></pre>
<p>在前面的 JConsole 示例中，我们可以看到 JMX 的 MBeanServer 里的所有 MBean 就是一个树结构，那么怎么定位一个 MBean 对象，就是靠它的地址，ObjectName 属性，例如例子里的 <code>user:name=User</code>。ObjectName 跟 LDAP 里定位的 DN 非常像，可以直接在客户端拿到一个服务端实际对象的代理对象。然后进行操作：</p>
<ul>
<li>queryMBeans：查询当前 Server 的所有 MBean 对象，进而可以拿到每个 MBean 内的 MBeanInfo 信息，有什么属性和方法。</li>
<li>getAttribute：从 Server 上拿到某个 MBean 对象的某个属性值。</li>
<li>setAttribute：设置 Server 上的某个 MBean 的某个属性值。</li>
<li>invoke：调用 Server 上某个 MBean 的某个方法。</li>
</ul>
<p>从上面的分析，我们可以看到，JMX 其实是基于 MBean 和 MBeanServer 模型、RMI 协议，在设计上非常精巧的远程调用技术。通过学习这个技术的细节，我们可以了解一般的 RPC 等技术。学会了这种 JVM 默认的管理 API 技术，我们也可以更方便的了解和分析 JVM 情况。</p>
<h2>更多用法</h2>
<p>JMX 是基于 RMI 的 JVM 管理技术，底层是 Java 平台专有的 RMI 远程方法调用，很难做到跨语言调用。怎么才能做到跨平台呢？现在最火的远程调用方式非 REST 莫属。能否让 JMX 使用 REST API 直接调用呢？答案是肯定的。</p>
<p>另外，想要进行性能分析，只有 JVM 的信息还是不够的，我们还需要跟其他的各类监控集成，比如 Datadog 或是其他 APM，本篇只是简单涉及。</p>
<h3>JMX 与 REST API</h3>
<p>先说一下 JMX 的 REST API，有一个框架 Jolokia，它可以自动把 JMX 的结构转换成 REST API 和 JSON 数据。在开源软件 ActiveMQ 的控制台里就默认使用了这个框架，这样可以直接达到如下效果。</p>
<p>我们使用 curl 手工执行一次 REST 调用，会直接返回给我们 API 的 JSON 结果。</p>
<pre><code class="language-shell">$ curl http://localhost:8161/hawtio/jolokia/read/org.apache.activemq:brokerName=localhost,type=Broker/Queues

{&quot;timestamp&quot;:1392110578,&quot;status&quot;:200,&quot;request&quot;:{&quot;mbean&quot;:&quot;org.apache.activemq:brokerName=localhost,type=Broker&quot;,&quot;attribute&quot;:&quot;Queues&quot;,&quot;type&quot;:&quot;read&quot;},&quot;value&quot;:[{&quot;objectName&quot;:&quot;org.apache.activemq:brokerName=localhost,destinationName=a,destinationType=Queue,type=Broker&quot;}]}

</code></pre>
<p>更多信息，可以阅读参考材料。</p>
<h3>JMX 与其他软件</h3>
<p>JConsole 及 JVisualVM 等工具提供了实时查看的能力，但如果我们想监控大量 JVM 实例的历史数据，应该怎么办呢?</p>
<p>既然 JMX 提供了这些数据，只要我们有一个工具来定时采集，并上报给对应的 APM 收集系统，那么我们就保存了长期的历史数据，作为进一步分析和性能诊断的依据。</p>
<p>例如 DataDog，听云等服务提供商都集成了对 JMX 的支持。</p>
<p>因为我们的专栏主要讲解 JDK 相关工具的用法，所以想了解的同学请搜索关键字，如：“Datadog JMX”或者“听云 JMX”等等。</p>
<blockquote>
<p>如果你搜索“Spring JMX“，甚至能看到 JMX 可以把很多东西玩出花来，但 JMX 比起 HTTP API 来说还是比较重的，所以对于具有编程能力的企业和工程师来说，想要灵活和方便的话，HTTP 接口才是最方便的方式。</p>
</blockquote>
<h2>相关链接</h2>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jmx/index.html">Java Management Extensions (JMX) Guide</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/index.html">Monitoring and Management for the Java Platform</a></li>
<li><a href="https://blog.csdn.net/kimmking/article/details/9170563">在 ActiveMQ 中使用 JMX</a></li>
<li><a href="https://jolokia.org/">Jolokia is remote JMX with JSON over HTTP.</a></li>
<li><a href="https://blog.csdn.net/KimmKing/article/details/19081973">ActiveMQ REST Management API</a></li>
</ul>
</div>
                    </div>
                    <div>
                        <div style="float: left">
                            <a href="11&#32;JDWP&#32;简介：十步杀一人，千里不留行.md">上一页</a>
                        </div>
                        <div style="float: right">
                            <a href="13&#32;常见的&#32;GC&#32;算法（GC&#32;的背景与原理）.md">下一页</a>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v64f9daad31f64f81be21cbef6184a5e31634941392597" integrity="sha512-gV/bogrUTVP2N3IzTDKzgP0Js1gg4fbwtYB6ftgLbKQu/V8yH2+lrKCfKHelh4SO3DPzKj4/glTO+tNJGDnb0A==" data-cf-beacon='{"rayId":"6b4340ca1ab870ac","version":"2021.11.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/&quot;&#32;+&#32;cookie&#32;+&#32;&quot;'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }
</script>

</html>
