<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>19 GC 日志解读与分析（实例分析中篇）.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
    </head>

<body>

<div class="book-container">
    <div class="book-sidebar">
        <div class="book-brand">
            <a href="../../index.html">
                <img src="../../static/favicon.png">
                <span>技术文章摘抄</span>
            </a>
        </div>
        <div class="book-menu uncollapsible">
            <ul class="uncollapsible">
                <li><a href="../../index.html" class="current-tab">首页</a></li>
            </ul>

            <ul class="uncollapsible">
                <li><a href="../index.html">上一级</a></li>
            </ul>

            <ul class="uncollapsible">
                <li>

                    
                    <a href="01&#32;阅读此专栏的正确姿势.md">01 阅读此专栏的正确姿势.md</a>

                </li>
                <li>

                    
                    <a href="02&#32;环境准备：千里之行，始于足下.md">02 环境准备：千里之行，始于足下.md</a>

                </li>
                <li>

                    
                    <a href="03&#32;常用性能指标：没有量化，就没有改进.md">03 常用性能指标：没有量化，就没有改进.md</a>

                </li>
                <li>

                    
                    <a href="04&#32;JVM&#32;基础知识：不积跬步，无以至千里.md">04 JVM 基础知识：不积跬步，无以至千里.md</a>

                </li>
                <li>

                    
                    <a href="05&#32;Java&#32;字节码技术：不积细流，无以成江河.md">05 Java 字节码技术：不积细流，无以成江河.md</a>

                </li>
                <li>

                    
                    <a href="06&#32;Java&#32;类加载器：山不辞土，故能成其高.md">06 Java 类加载器：山不辞土，故能成其高.md</a>

                </li>
                <li>

                    
                    <a href="07&#32;Java&#32;内存模型：海不辞水，故能成其深.md">07 Java 内存模型：海不辞水，故能成其深.md</a>

                </li>
                <li>

                    
                    <a href="08&#32;JVM&#32;启动参数详解：博观而约取、厚积而薄发.md">08 JVM 启动参数详解：博观而约取、厚积而薄发.md</a>

                </li>
                <li>

                    
                    <a href="09&#32;JDK&#32;内置命令行工具：工欲善其事，必先利其器.md">09 JDK 内置命令行工具：工欲善其事，必先利其器.md</a>

                </li>
                <li>

                    
                    <a href="10&#32;JDK&#32;内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md">10 JDK 内置图形界面工具：海阔凭鱼跃，天高任鸟飞.md</a>

                </li>
                <li>

                    
                    <a href="11&#32;JDWP&#32;简介：十步杀一人，千里不留行.md">11 JDWP 简介：十步杀一人，千里不留行.md</a>

                </li>
                <li>

                    
                    <a href="12&#32;JMX&#32;与相关工具：山高月小，水落石出.md">12 JMX 与相关工具：山高月小，水落石出.md</a>

                </li>
                <li>

                    
                    <a href="13&#32;常见的&#32;GC&#32;算法（GC&#32;的背景与原理）.md">13 常见的 GC 算法（GC 的背景与原理）.md</a>

                </li>
                <li>

                    
                    <a href="14&#32;常见的&#32;GC&#32;算法（ParallelCMSG1）.md">14 常见的 GC 算法（ParallelCMSG1）.md</a>

                </li>
                <li>

                    
                    <a href="15&#32;Java11&#32;ZGC&#32;和&#32;Java12&#32;Shenandoah&#32;介绍：苟日新、日日新、又日新.md">15 Java11 ZGC 和 Java12 Shenandoah 介绍：苟日新、日日新、又日新.md</a>

                </li>
                <li>

                    
                    <a href="16&#32;Oracle&#32;GraalVM&#32;介绍：会当凌绝顶、一览众山小.md">16 Oracle GraalVM 介绍：会当凌绝顶、一览众山小.md</a>

                </li>
                <li>

                    
                    <a href="17&#32;GC&#32;日志解读与分析（基础配置）.md">17 GC 日志解读与分析（基础配置）.md</a>

                </li>
                <li>

                    
                    <a href="18&#32;GC&#32;日志解读与分析（实例分析上篇）.md">18 GC 日志解读与分析（实例分析上篇）.md</a>

                </li>
                <li>

                    <a class="current-tab" href="19&#32;GC&#32;日志解读与分析（实例分析中篇）.md">19 GC 日志解读与分析（实例分析中篇）.md</a>
                    

                </li>
                <li>

                    
                    <a href="20&#32;GC&#32;日志解读与分析（实例分析下篇）.md">20 GC 日志解读与分析（实例分析下篇）.md</a>

                </li>
                <li>

                    
                    <a href="21&#32;GC&#32;日志解读与分析（番外篇可视化工具）.md">21 GC 日志解读与分析（番外篇可视化工具）.md</a>

                </li>
                <li>

                    
                    <a href="22&#32;JVM&#32;的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md">22 JVM 的线程堆栈等数据分析：操千曲而后晓声、观千剑而后识器.md</a>

                </li>
                <li>

                    
                    <a href="23&#32;内存分析与相关工具上篇（内存布局与分析工具）.md">23 内存分析与相关工具上篇（内存布局与分析工具）.md</a>

                </li>
                <li>

                    
                    <a href="24&#32;内存分析与相关工具下篇（常见问题分析）.md">24 内存分析与相关工具下篇（常见问题分析）.md</a>

                </li>
                <li>

                    
                    <a href="25&#32;FastThread&#32;相关的工具介绍：欲穷千里目，更上一层楼.md">25 FastThread 相关的工具介绍：欲穷千里目，更上一层楼.md</a>

                </li>
                <li>

                    
                    <a href="26&#32;面临复杂问题时的几个高级工具：它山之石，可以攻玉.md">26 面临复杂问题时的几个高级工具：它山之石，可以攻玉.md</a>

                </li>
                <li>

                    
                    <a href="27&#32;JVM&#32;问题排查分析上篇（调优经验）.md">27 JVM 问题排查分析上篇（调优经验）.md</a>

                </li>
                <li>

                    
                    <a href="28&#32;JVM&#32;问题排查分析下篇（案例实战）.md">28 JVM 问题排查分析下篇（案例实战）.md</a>

                </li>
                <li>

                    
                    <a href="29&#32;GC&#32;疑难情况问题排查与分析（上篇）.md">29 GC 疑难情况问题排查与分析（上篇）.md</a>

                </li>
                <li>

                    
                    <a href="30&#32;GC&#32;疑难情况问题排查与分析（下篇）.md">30 GC 疑难情况问题排查与分析（下篇）.md</a>

                </li>
                <li>

                    
                    <a href="31&#32;JVM&#32;相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md">31 JVM 相关的常见面试问题汇总：运筹策帷帐之中，决胜于千里之外.md</a>

                </li>
                <li>

                    
                    <a href="32&#32;应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md">32 应对容器时代面临的挑战：长风破浪会有时、直挂云帆济沧海.md</a>

                </li>
            </ul>

        </div>
    </div>

    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
        <div class="sidebar-toggle-inner"></div>
    </div>

    <script>
        function add_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.add('show')
        }

        function remove_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.remove('show')
        }

        function sidebar_toggle() {
            let sidebar_toggle = document.querySelector('.sidebar-toggle')
            let sidebar = document.querySelector('.book-sidebar')
            let content = document.querySelector('.off-canvas-content')
            if (sidebar_toggle.classList.contains('extend')) { // show
                sidebar_toggle.classList.remove('extend')
                sidebar.classList.remove('hide')
                content.classList.remove('extend')
            } else { // hide
                sidebar_toggle.classList.add('extend')
                sidebar.classList.add('hide')
                content.classList.add('extend')
            }
        }
    </script>

    <div class="off-canvas-content">
        <div class="columns">
            <div class="column col-12 col-lg-12">
                <div class="book-navbar">
                    <!-- For Responsive Layout -->
                    <header class="navbar">
                        <section class="navbar-section">
                            <a onclick="open_sidebar()">
                                <i class="icon icon-menu"></i>
                            </a>
                        </section>
                    </header>
                </div>
                <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                    <div class="book-post">
                        <p id="tip" align="center"></p>
                        <div><h1>19 GC 日志解读与分析（实例分析中篇）</h1>
<h3>CMS 的 GC 日志解读</h3>
<p>CMS 也可称为“并发标记清除垃圾收集器”。其设计目标是避免在老年代 GC 时出现长时间的卡顿。默认情况下，CMS 使用的并发线程数等于 CPU 内核数的 1/4。</p>
<p>通过以下选项来指定 CMS 垃圾收集器：</p>
<pre><code class="language-shell">-XX:+UseConcMarkSweepGC

</code></pre>
<p>如果 CPU 资源受限，CMS 的吞吐量会比并行 GC 差一些。示例：</p>
<pre><code class="language-shell"># 请注意命令行启动时没有换行，此处是方便大家阅读。
java -XX:+UseConcMarkSweepGC
-Xms512m
-Xmx512m
-Xloggc：gc.demo.log
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
demo.jvm0204.GCLogAnalysis

</code></pre>
<p>和前面分析的串行 GC/并行 GC 一样，我们将程序启动起来，看看 CMS 算法生成的 GC 日志是什么样子：</p>
<pre><code class="language-shell">Java HotSpot(TM) 64-Bit Server VM (25.162-b12) 。。。
Memory： 4k page，physical 16777216k(1168104k free)

CommandLine flags：
  -XX:InitialHeapSize=536870912 -XX:MaxHeapSize=536870912
  -XX:MaxNewSize=178958336 -XX:MaxTenuringThreshold=6
  -XX:NewSize=178958336 -XX:OldPLABSize=16 -XX:OldSize=357912576
  -XX:+PrintGC -XX:+PrintGCDateStamps
  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
  -XX:+UseCompressedClassPointers -XX:+UseCompressedOops
  -XX:+UseConcMarkSweepGC -XX:+UseParNewGC

2019-12-22T00:00:31.865-0800: 1.067：
  [GC (Allocation Failure)
    2019-12-22T00:00:31.865-0800: 1.067：
    [ParNew： 136418K-&gt;17311K(157248K)，0.0233955 secs]
    442378K-&gt;360181K(506816K)，0.0234719 secs]
  [Times: user=0.10 sys=0.02，real=0.02 secs]

2019-12-22T00:00:31.889-0800: 1.091：
  [GC (CMS Initial Mark)
    [1 CMS-initial-mark: 342870K(349568K)]
    363883K(506816K)，0.0002262 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.889-0800: 1.091：
  [CMS-concurrent-mark-start]
2019-12-22T00:00:31.890-0800: 1.092：
  [CMS-concurrent-mark: 0.001/0.001 secs]
  [Times: user=0.00 sys=0.00,real=0.01 secs]
2019-12-22T00:00:31.891-0800: 1.092：
  [CMS-concurrent-preclean-start]
2019-12-22T00:00:31.891-0800: 1.093：
  [CMS-concurrent-preclean: 0.001/0.001 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.891-0800: 1.093：
  [CMS-concurrent-abortable-preclean-start]
2019-12-22T00:00:31.891-0800: 1.093：
  [CMS-concurrent-abortable-preclean: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.891-0800: 1.093：
  [GC (CMS Final Remark)
    [YG occupancy: 26095 K (157248 K)]
    2019-12-22T00:00:31.891-0800: 1.093：
      [Rescan (parallel) ，0.0002680 secs]
    2019-12-22T00:00:31.891-0800: 1.093：
      [weak refs processing，0.0000230 secs]
    2019-12-22T00:00:31.891-0800: 1.093：
      [class unloading，0.0004008 secs]
    2019-12-22T00:00:31.892-0800: 1.094：
      [scrub symbol table，0.0006072 secs]
    2019-12-22T00:00:31.893-0800: 1.095：
      [scrub string table，0.0001769 secs]
      [1 CMS-remark: 342870K(349568K)]
    368965K(506816K)，0.0015928 secs]
  [Times: user=0.01 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.893-0800: 1.095：
  [CMS-concurrent-sweep-start]
2019-12-22T00:00:31.893-0800: 1.095：
  [CMS-concurrent-sweep： 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.893-0800: 1.095：
  [CMS-concurrent-reset-start]
2019-12-22T00:00:31.894-0800: 1.096：
  [CMS-concurrent-reset: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>这只是摘录的一部分 GC 日志。比起串行 GC/并行 GC 来说，CMS 的日志信息复杂了很多，这一方面是因为 CMS 拥有更加精细的 GC 步骤，另一方面 GC 日志很详细就意味着暴露出来的信息也就更全面细致。</p>
<h4><strong>Minor GC 日志分析</strong></h4>
<p>最前面的几行日志是清理年轻代的 Minor GC 事件：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.865-0800: 1.067：
  [GC (Allocation Failure)
    2019-12-22T00:00:31.865-0800: 1.067：
    [ParNew： 136418K-&gt;17311K(157248K)，0.0233955 secs]
    442378K-&gt;360181K(506816K)，0.0234719 secs]
  [Times: user=0.10 sys=0.02，real=0.02 secs]

</code></pre>
<p>我们一起来解读：</p>
<ol>
<li><code>2019-12-22T00:00:31.865-0800: 1.067</code>：GC 事件开始的时间。</li>
<li><code>GC (Allocation Failure)</code>：用来区分 Minor GC 还是 Full GC 的标志。<code>GC</code> 表明这是一次“小型 GC”；<code>Allocation Failure</code> 表示触发 GC 的原因。本次 GC 事件，是由于年轻代可用空间不足，新对象的内存分配失败引起的。</li>
<li><code>[ParNew： 136418K-&gt;17311K(157248K)，0.0233955 secs]</code>：其中 <code>ParNew</code> 是垃圾收集器的名称，对应的就是前面日志中打印的 <code>-XX:+UseParNewGC</code> 这个命令行标志。表示在年轻代中使用的“并行的标记—复制（mark-copy）”垃圾收集器，专门设计了用来配合 CMS 垃圾收集器，因为 CMS 只负责回收老年代。后面的数字表示 GC 前后的年轻代使用量变化，以及年轻代的总大小。<code>0.0233955 secs</code> 是消耗的时间。</li>
<li><code>442378K-&gt;360181K(506816K)，0.0234719 secs</code>：表示 GC 前后堆内存的使用量变化，以及堆内存空间的大小。消耗的时间是 <code>0.0234719 secs</code>，和前面的 ParNew 部分的时间基本上一样。</li>
<li><code>[Times: user=0.10 sys=0.02，real=0.02 secs]</code>：GC 事件的持续时间。<code>user</code> 是 GC 线程所消耗的总 CPU 时间；<code>sys</code> 是操作系统调用和系统等待事件消耗的时间；应用程序实际暂停的时间 <code>real ~= (user + sys)/GC线程数</code>。我的机器是 4 核 8 线程，而这里是 6 倍的比例，因为总有一定比例的处理过程是不能并行执行的。</li>
</ol>
<p>进一步计算和分析可以得知，在 GC 之前，年轻代使用量为 136418K/157248K=86%。堆内存的使用率为 442378K/506816K=87%。稍微估算一下，老年代的使用率为：(442378K-136418K)/(506816K-157248K)=(305960K /349568K)=87%。这里是凑巧了，GC 之前 3 个比例都在 87% 左右。</p>
<p>GC 之后呢？年轻代使用量为 17311K ~= 17%，下降了 119107K。堆内存使用量为 360181K ~= 71%，只下降了 82197K。两个下降值相减，就是年轻代提升到老年代的内存量：119107-82197=36910K。</p>
<p>那么老年代空间有多大？老年代使用量是多少？正在阅读的同学，请开动脑筋，用这些数字算一下。</p>
<p>此次 GC 的内存变化示意图为：</p>
<p><img src="assets/13640c30-63ac-11ea-a283-8f19fc193c49" alt="4438116.png" /></p>
<p>哇塞，这个数字不得了，老年代使用量 98% 了，非常高了。后面紧跟着就是一条 Full GC 的日志，请接着往下看。</p>
<h4><strong>Full GC 日志分析</strong></h4>
<p>实际上这次截取的年轻代 GC 日志和 FullGC 日志是紧连着的，我们从间隔时间也能大致看出来，<code>1.067 + 0.02secs ~ 1.091</code>。</p>
<p>CMS 的日志是一种完全不同的格式，并且很长，因为 CMS 对老年代进行垃圾收集时每个阶段都会有自己的日志。为了简洁，我们将对这部分日志按照阶段依次介绍。</p>
<p>首先来看 CMS 这次 FullGC 的日志：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.889-0800: 1.091:
  [GC (CMS Initial Mark)
    [1 CMS-initial-mark: 342870K(349568K)]
    363883K(506816K)，0.0002262 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.889-0800: 1.091:
  [CMS-concurrent-mark-start]
2019-12-22T00:00:31.890-0800: 1.092:
  [CMS-concurrent-mark: 0.001/0.001 secs]
  [Times: user=0.00 sys=0.00,real=0.01 secs]
2019-12-22T00:00:31.891-0800: 1.092:
  [CMS-concurrent-preclean-start]
2019-12-22T00:00:31.891-0800: 1.093:
  [CMS-concurrent-preclean: 0.001/0.001 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.891-0800: 1.093:
  [CMS-concurrent-abortable-preclean-start]
2019-12-22T00:00:31.891-0800: 1.093:
  [CMS-concurrent-abortable-preclean: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.891-0800: 1.093:
  [GC (CMS Final Remark)
    [YG occupancy: 26095 K (157248 K)]
    2019-12-22T00:00:31.891-0800: 1.093:
      [Rescan (parallel) ，0.0002680 secs]
    2019-12-22T00:00:31.891-0800: 1.093:
      [weak refs processing，0.0000230 secs]
    2019-12-22T00:00:31.891-0800: 1.093:
      [class unloading，0.0004008 secs]
    2019-12-22T00:00:31.892-0800: 1.094:
      [scrub symbol table，0.0006072 secs]
    2019-12-22T00:00:31.893-0800: 1.095:
      [scrub string table，0.0001769 secs]
      [1 CMS-remark: 342870K(349568K)]
    368965K(506816K)，0.0015928 secs]
  [Times: user=0.01 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.893-0800: 1.095:
  [CMS-concurrent-sweep-start]
2019-12-22T00:00:31.893-0800: 1.095:
  [CMS-concurrent-sweep： 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]
2019-12-22T00:00:31.893-0800: 1.095:
  [CMS-concurrent-reset-start]
2019-12-22T00:00:31.894-0800: 1.096:
  [CMS-concurrent-reset: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>在实际运行中，CMS 在进行老年代的并发垃圾回收时，可能会伴随着多次年轻代的 Minor GC（想想是为什么）。在这种情况下，Full GC 的日志中可能会掺杂着多次 Minor GC 事件。</p>
<p><strong>阶段 1：Initial Mark（初始标记）</strong></p>
<p>前面章节提到过，这个阶段伴随着 STW 暂停。初始标记的目标是标记所有的根对象，包括 GC ROOT 直接引用的对象，以及被年轻代中所有存活对象所引用的对象。后面这部分也非常重要，因为老年代是独立进行回收的。</p>
<p>先看这个阶段的日志：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.889-0800: 1.091:
  [GC (CMS Initial Mark)
    [1 CMS-initial-mark: 342870K(349568K)]
    363883K(506816K), 0.0002262 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>让我们简单解读一下：</p>
<ol>
<li><code>2019-12-22T00:00:31.889-0800: 1.091:</code>：时间部分就不讲了，参考前面的解读。后面的其他阶段也一样，不再进行重复介绍。</li>
<li><code>CMS Initial Mark</code>：这个阶段的名称为“Initial Mark”，会标记所有的 GC Root。</li>
<li><code>[1 CMS-initial-mark: 342870K(349568K)]</code>：这部分数字表示老年代的使用量，以及老年代的空间大小。</li>
<li><code>363883K(506816K)，0.0002262 secs</code>：当前堆内存的使用量，以及可用堆的大小、消耗的时间。可以看出这个时间非常短，只有 0.2 毫秒左右，因为要标记的这些 Roo 数量很少。</li>
<li><code>[Times: user=0.00 sys=0.00,real=0.00 secs]</code>：初始标记事件暂停的时间，可以看到可以忽略不计。</li>
</ol>
<p><strong>阶段 2：Concurrent Mark（并发标记）</strong></p>
<p>在并发标记阶段，CMS 从前一阶段“Initial Mark”找到的 ROOT 开始算起，遍历老年代并标记所有的存活对象。</p>
<p>看看这个阶段的 GC 日志：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.889-0800: 1.091:
  [CMS-concurrent-mark-start]
2019-12-22T00:00:31.890-0800: 1.092:
  [CMS-concurrent-mark: 0.001/0.001 secs]
  [Times: user=0.00 sys=0.00,real=0.01 secs]

</code></pre>
<p>简单解读一下：</p>
<ol>
<li><code>CMS-concurrent-mark</code>：指明了是 CMS 垃圾收集器所处的阶段为并发标记（“Concurrent Mark”）。</li>
<li><code>0.001/0.001 secs</code>：此阶段的持续时间，分别是 GC 线程消耗的时间和实际消耗的时间。</li>
<li><code>[Times: user=0.00 sys=0.00,real=0.01 secs]</code>：<code>Times</code> 对并发阶段来说这些时间并没多少意义，因为是从并发标记开始时刻计算的，而这段时间应用线程也在执行，所以这个时间只是一个大概的值。</li>
</ol>
<p><strong>阶段 3：Concurrent Preclean（并发预清理）</strong></p>
<p>此阶段同样是与应用线程并发执行的，不需要停止应用线程。</p>
<p>看看并发预清理阶段的 GC 日志：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.891-0800: 1.092:
  [CMS-concurrent-preclean-start]
2019-12-22T00:00:31.891-0800: 1.093:
  [CMS-concurrent-preclean: 0.001/0.001 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>简单解读：</p>
<ol>
<li><code>CMS-concurrent-preclean</code>：表明这是并发预清理阶段的日志，这个阶段会统计前面的并发标记阶段执行过程中发生了改变的对象。</li>
<li><code>0.001/0.001 secs</code>：此阶段的持续时间，分别是 GC 线程运行时间和实际占用的时间。</li>
<li><code>[Times: user=0.00 sys=0.00,real=0.00 secs]</code>：Times 这部分对并发阶段来说没多少意义，因为是从开始时间计算的，而这段时间内不仅 GC 线程在执行并发预清理，应用线程也在运行。</li>
</ol>
<p><strong>阶段 4：Concurrent Abortable Preclean（可取消的并发预清理）</strong></p>
<p>此阶段也不停止应用线程，尝试在会触发 STW 的 Final Remark 阶段开始之前，尽可能地多干一些活。</p>
<p>本阶段的具体时间取决于多种因素，因为它循环做同样的事情，直到满足某一个退出条件（如迭代次数、有用工作量、消耗的系统时间等等）。</p>
<p>看看 GC 日志：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.891-0800: 1.093:
  [CMS-concurrent-abortable-preclean-start]
2019-12-22T00:00:31.891-0800: 1.093:
  [CMS-concurrent-abortable-preclean: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>简单解读：</p>
<ol>
<li><code>CMS-concurrent-abortable-preclean</code>：指示此阶段的名称：“Concurrent Abortable Preclean”。</li>
<li><code>0.000/0.000 secs</code>：此阶段 GC 线程的运行时间和实际占用的时间。从本质上讲，GC 线程试图在执行 STW 暂停之前等待尽可能长的时间。默认条件下，此阶段可以持续最长 5 秒钟的时间。</li>
<li><code>[Times: user=0.00 sys=0.00,real=0.00 secs]</code>：“Times”这部分对并发阶段来说没多少意义，因为程序在并发阶段中持续运行。</li>
</ol>
<p>此阶段完成的工作可能对 STW 停顿的时间有较大影响，并且有许多重要的<a href="https://blogs.oracle.com/jonthecollector/entry/did_you_know">配置选项</a>和失败模式。</p>
<p><strong>阶段 5：Final Remark（最终标记）</strong></p>
<p>最终标记阶段是此次 GC 事件中的第二次（也是最后一次）STW 停顿。</p>
<p>本阶段的目标是完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。</p>
<p>通常 CMS 会尝试在年轻代尽可能空的情况下执行 final remark 阶段，以免连续触发多次 STW 事件。</p>
<p>这部分的 GC 日志看起来稍微复杂一些：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.891-0800: 1.093:
  [GC (CMS Final Remark)
    [YG occupancy: 26095 K (157248 K)]
    2019-12-22T00:00:31.891-0800: 1.093:
      [Rescan (parallel) ，0.0002680 secs]
    2019-12-22T00:00:31.891-0800: 1.093:
      [weak refs processing，0.0000230 secs]
    2019-12-22T00:00:31.891-0800: 1.093:
      [class unloading，0.0004008 secs]
    2019-12-22T00:00:31.892-0800: 1.094:
      [scrub symbol table，0.0006072 secs]
    2019-12-22T00:00:31.893-0800: 1.095:
      [scrub string table，0.0001769 secs]
      [1 CMS-remark: 342870K(349568K)]
    368965K(506816K)，0.0015928 secs]
  [Times: user=0.01 sys=0.00,real=0.00 secs]

</code></pre>
<p>一起来进行解读：</p>
<ol>
<li><code>CMS Final Remark</code>：这是此阶段的名称，最终标记阶段，会标记老年代中所有的存活对象，包括此前的并发标记过程中创建/修改的引用。</li>
<li><code>YG occupancy: 26095 K (157248 K)</code>：当前年轻代的使用量和总容量。</li>
<li><code>[Rescan (parallel) ，0.0002680 secs]</code>：在程序暂停后进行重新扫描（Rescan），以完成存活对象的标记。这部分是并行执行的，消耗的时间为 0.0002680 秒。</li>
<li><code>weak refs processing，0.0000230 secs</code>：第一个子阶段，处理弱引用的持续时间。</li>
<li><code>class unloading，0.0004008 secs</code>：第二个子阶段，卸载不使用的类，以及持续时间。</li>
<li><code>scrub symbol table，0.0006072 secs</code>：第三个子阶段，清理符号表，即持有 class 级别 metadata 的符号表（symbol tables）。</li>
<li><code>scrub string table，0.0001769 secs</code>：第四个子阶段， 清理内联字符串对应的 string tables。</li>
<li><code>[1 CMS-remark: 342870K(349568K)]</code>：此阶段完成后老年代的使用量和总容量。</li>
<li><code>368965K(506816K)，0.0015928 secs</code>：此阶段完成后，整个堆内存的使用量和总容量。</li>
<li><code>[Times: user=0.01 sys=0.00,real=0.00 secs]</code>：GC 事件的持续时间。</li>
</ol>
<p>在这 5 个标记阶段完成后，老年代中的所有存活对象都被标记上了，接下来 JVM 会将所有不使用的对象清除，以回收老年代空间。</p>
<p><strong>阶段 6：Concurrent Sweep（并发清除）</strong></p>
<p>此阶段与应用程序并发执行，不需要 STW 停顿。目的是删除不再使用的对象，并回收他们占用的内存空间。</p>
<p>看看这部分的 GC 日志：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.893-0800: 1.095:
  [CMS-concurrent-sweep-start]
2019-12-22T00:00:31.893-0800: 1.095:
  [CMS-concurrent-sweep: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>简单解读：</p>
<ol>
<li><code>CMS-concurrent-sweep</code>：此阶段的名称，“Concurrent Sweep”，并发清除老年代中所有未被标记的对象、也就是不再使用的对象，以释放内存空间。</li>
<li><code>0.000/0.000 secs</code>：此阶段的持续时间和实际占用的时间，这是一个四舍五入值，只精确到小数点后 3 位。</li>
<li><code>[Times: user=0.00 sys=0.00,real=0.00 secs]</code>：“Times”部分对并发阶段来说没有多少意义，因为是从并发标记开始时计算的，而这段时间内不仅是并发标记线程在执行，程序线程也在运行。</li>
</ol>
<p><strong>阶段 7：Concurrent Reset（并发重置）</strong></p>
<p>此阶段与应用程序线程并发执行，重置 CMS 算法相关的内部数据结构，下一次触发 GC 时就可以直接使用。</p>
<p>对应的日志为：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.893-0800: 1.095:
  [CMS-concurrent-reset-start]
2019-12-22T00:00:31.894-0800: 1.096:
  [CMS-concurrent-reset: 0.000/0.000 secs]
  [Times: user=0.00 sys=0.00,real=0.00 secs]

</code></pre>
<p>简单解读：</p>
<ol>
<li><code>CMS-concurrent-reset</code>：此阶段的名称，“Concurrent Reset”，重置 CMS 算法的内部数据结构，为下一次 GC 循环做准备。</li>
<li><code>0.000/0.000 secs</code>：此阶段的持续时间和实际占用的时间</li>
<li><code>[Times: user=0.00 sys=0.00,real=0.00 secs]</code>：“Times”部分对并发阶段来说没多少意义，因为是从并发标记开始时计算的，而这段时间内不仅 GC 线程在运行，程序也在运行。</li>
</ol>
<p>那么问题来了，CMS 之后老年代内存使用量是多少呢？很抱歉这里分析不了，只能通过后面的 Minor GC 日志来分析了。</p>
<p>例如本次运行，后面的 GC 日志是这样的：</p>
<pre><code class="language-shell">2019-12-22T00:00:31.921-0800: 1.123:
  [GC (Allocation Failure) 2019-12-22T00:00:31.921-0800: 1.123:
    [ParNew: 153242K-&gt;16777K(157248K), 0.0070050 secs]
    445134K-&gt;335501K(506816K)，
    0.0070758 secs]
  [Times: user=0.05 sys=0.00,real=0.00 secs]

</code></pre>
<p>参照前面年轻代 GC 日志的分析方法，我们推算出来，上面的 CMS Full GC 之后，老年代的使用量应该是：445134K-153242K=291892K，老年代的总容量 506816K-157248K=349568K，所以 Full GC 之后老年代的使用量占比是 291892K/349568K=83%。</p>
<p>这个占比不低。说明什么问题呢？ 一般来说就是分配的内存小了，毕竟我们才指定了 512MB 的最大堆内存。</p>
<p>按照惯例，来一张 GC 前后的内存使用情况示意图：</p>
<p><img src="assets/7fad0940-63ad-11ea-9c08-6f91e6eaabb6" alt="3110993.png" /></p>
<p>总之，CMS 垃圾收集器在减少停顿时间上做了很多给力的工作，很大一部分 GC 线程是与应用线程并发运行的，不需要暂停应用线程，这样就可以在一般情况下每次暂停的时候较少。当然，CMS 也有一些缺点，其中最大的问题就是老年代的内存碎片问题，在某些情况下 GC 会有不可预测的暂停时间，特别是堆内存较大的情况下。</p>
<blockquote>
<p>透露一个学习 CMS 的诀窍：参考上面各个阶段的示意图，请同学们自己画一遍。</p>
</blockquote>
<p>本节的学习到此就结束了，下一节我们继续介绍 G1 日志分析。</p>
</div>
                    </div>
                    <div>
                        <div style="float: left">
                            <a href="18&#32;GC&#32;日志解读与分析（实例分析上篇）.md">上一页</a>
                        </div>
                        <div style="float: right">
                            <a href="20&#32;GC&#32;日志解读与分析（实例分析下篇）.md">下一页</a>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v64f9daad31f64f81be21cbef6184a5e31634941392597" integrity="sha512-gV/bogrUTVP2N3IzTDKzgP0Js1gg4fbwtYB6ftgLbKQu/V8yH2+lrKCfKHelh4SO3DPzKj4/glTO+tNJGDnb0A==" data-cf-beacon='{"rayId":"6b4340f7aa6670ac","version":"2021.11.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/JVM%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2032%20%E8%AE%B2%EF%BC%88%E5%AE%8C%EF%BC%89/&quot;&#32;+&#32;cookie&#32;+&#32;&quot;'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }
</script>

</html>
