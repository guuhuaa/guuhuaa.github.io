<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>05  数据库类型体系与 Java 类型体系之间的“爱恨情仇”.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
    </head>

<body>

<div class="book-container">
    <div class="book-sidebar">
        <div class="book-brand">
            <a href="../../index.html">
                <img src="../../static/favicon.png">
                <span>技术文章摘抄</span>
            </a>
        </div>
        <div class="book-menu uncollapsible">
            <ul class="uncollapsible">
                <li><a href="../../index.html" class="current-tab">首页</a></li>
            </ul>

            <ul class="uncollapsible">
                <li><a href="../index.html">上一级</a></li>
            </ul>

            <ul class="uncollapsible">
                <li>

                    
                    <a href="00&#32;开篇词&#32;&#32;领略&#32;MyBatis&#32;设计思维，突破持久化技术瓶颈.md">00 开篇词  领略 MyBatis 设计思维，突破持久化技术瓶颈.md</a>

                </li>
                <li>

                    
                    <a href="01&#32;&#32;常见持久层框架赏析，到底是什么让你选择&#32;MyBatis？.md">01  常见持久层框架赏析，到底是什么让你选择 MyBatis？.md</a>

                </li>
                <li>

                    
                    <a href="02&#32;&#32;订单系统持久层示例分析，20&#32;分钟带你快速上手&#32;MyBatis.md">02  订单系统持久层示例分析，20 分钟带你快速上手 MyBatis.md</a>

                </li>
                <li>

                    
                    <a href="03&#32;&#32;MyBatis&#32;源码环境搭建及整体架构解析.md">03  MyBatis 源码环境搭建及整体架构解析.md</a>

                </li>
                <li>

                    
                    <a href="04&#32;&#32;MyBatis&#32;反射工具箱：带你领略不一样的反射设计思路.md">04  MyBatis 反射工具箱：带你领略不一样的反射设计思路.md</a>

                </li>
                <li>

                    <a class="current-tab" href="05&#32;&#32;数据库类型体系与&#32;Java&#32;类型体系之间的“爱恨情仇”.md">05  数据库类型体系与 Java 类型体系之间的“爱恨情仇”.md</a>
                    

                </li>
                <li>

                    
                    <a href="06&#32;&#32;日志框架千千万，MyBatis&#32;都能兼容的秘密是什么？.md">06  日志框架千千万，MyBatis 都能兼容的秘密是什么？.md</a>

                </li>
                <li>

                    
                    <a href="07&#32;&#32;深入数据源和事务，把握持久化框架的两个关键命脉.md">07  深入数据源和事务，把握持久化框架的两个关键命脉.md</a>

                </li>
                <li>

                    
                    <a href="08&#32;&#32;Mapper&#32;文件与&#32;Java&#32;接口的优雅映射之道.md">08  Mapper 文件与 Java 接口的优雅映射之道.md</a>

                </li>
                <li>

                    
                    <a href="09&#32;&#32;基于&#32;MyBatis&#32;缓存分析装饰器模式的最佳实践.md">09  基于 MyBatis 缓存分析装饰器模式的最佳实践.md</a>

                </li>
                <li>

                    
                    <a href="10&#32;&#32;鸟瞰&#32;MyBatis&#32;初始化，把握&#32;MyBatis&#32;启动流程脉络（上）.md">10  鸟瞰 MyBatis 初始化，把握 MyBatis 启动流程脉络（上）.md</a>

                </li>
                <li>

                    
                    <a href="11&#32;&#32;鸟瞰&#32;MyBatis&#32;初始化，把握&#32;MyBatis&#32;启动流程脉络（下）.md">11  鸟瞰 MyBatis 初始化，把握 MyBatis 启动流程脉络（下）.md</a>

                </li>
                <li>

                    
                    <a href="12&#32;&#32;深入分析动态&#32;SQL&#32;语句解析全流程（上）.md">12  深入分析动态 SQL 语句解析全流程（上）.md</a>

                </li>
                <li>

                    
                    <a href="13&#32;&#32;深入分析动态&#32;SQL&#32;语句解析全流程（下）.md">13  深入分析动态 SQL 语句解析全流程（下）.md</a>

                </li>
                <li>

                    
                    <a href="14&#32;&#32;探究&#32;MyBatis&#32;结果集映射机制背后的秘密（上）.md">14  探究 MyBatis 结果集映射机制背后的秘密（上）.md</a>

                </li>
                <li>

                    
                    <a href="15&#32;&#32;探究&#32;MyBatis&#32;结果集映射机制背后的秘密（下）.md">15  探究 MyBatis 结果集映射机制背后的秘密（下）.md</a>

                </li>
                <li>

                    
                    <a href="16&#32;&#32;StatementHandler：参数绑定、SQL&#32;执行和结果映射的奠基者.md">16  StatementHandler：参数绑定、SQL 执行和结果映射的奠基者.md</a>

                </li>
                <li>

                    
                    <a href="17&#32;&#32;Executor&#32;才是执行&#32;SQL&#32;语句的幕后推手（上）.md">17  Executor 才是执行 SQL 语句的幕后推手（上）.md</a>

                </li>
                <li>

                    
                    <a href="18&#32;&#32;Executor&#32;才是执行&#32;SQL&#32;语句的幕后推手（下）.md">18  Executor 才是执行 SQL 语句的幕后推手（下）.md</a>

                </li>
                <li>

                    
                    <a href="19&#32;&#32;深入&#32;MyBatis&#32;内核与业务逻辑的桥梁——接口层.md">19  深入 MyBatis 内核与业务逻辑的桥梁——接口层.md</a>

                </li>
                <li>

                    
                    <a href="20&#32;&#32;插件体系让&#32;MyBatis&#32;世界更加精彩.md">20  插件体系让 MyBatis 世界更加精彩.md</a>

                </li>
                <li>

                    
                    <a href="21&#32;&#32;深挖&#32;MyBatis&#32;与&#32;Spring&#32;集成底层原理.md">21  深挖 MyBatis 与 Spring 集成底层原理.md</a>

                </li>
                <li>

                    
                    <a href="22&#32;&#32;基于&#32;MyBatis&#32;的衍生框架一览.md">22  基于 MyBatis 的衍生框架一览.md</a>

                </li>
                <li>

                    
                    <a href="23&#32;结束语&#32;&#32;会使用只能默默“搬砖”，懂原理才能快速晋升.md">23 结束语  会使用只能默默“搬砖”，懂原理才能快速晋升.md</a>

                </li>
            </ul>

        </div>
    </div>

    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
        <div class="sidebar-toggle-inner"></div>
    </div>

    <script>
        function add_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.add('show')
        }

        function remove_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.remove('show')
        }

        function sidebar_toggle() {
            let sidebar_toggle = document.querySelector('.sidebar-toggle')
            let sidebar = document.querySelector('.book-sidebar')
            let content = document.querySelector('.off-canvas-content')
            if (sidebar_toggle.classList.contains('extend')) { // show
                sidebar_toggle.classList.remove('extend')
                sidebar.classList.remove('hide')
                content.classList.remove('extend')
            } else { // hide
                sidebar_toggle.classList.add('extend')
                sidebar.classList.add('hide')
                content.classList.add('extend')
            }
        }
    </script>

    <div class="off-canvas-content">
        <div class="columns">
            <div class="column col-12 col-lg-12">
                <div class="book-navbar">
                    <!-- For Responsive Layout -->
                    <header class="navbar">
                        <section class="navbar-section">
                            <a onclick="open_sidebar()">
                                <i class="icon icon-menu"></i>
                            </a>
                        </section>
                    </header>
                </div>
                <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                    <div class="book-post">
                        <p id="tip" align="center"></p>
                        <div><h1>05  数据库类型体系与 Java 类型体系之间的“爱恨情仇”</h1>
<p>作为一个 Java 程序员，你应该已经具备了使用 JDBC 操作数据库的基础技能。在使用 JDBC 的时候，你会发现 JDBC 的数据类型与 Java 语言中的数据类型虽然有点对应关系，如下图所示，但还是无法做到一一对应，也自然无法做到自动映射。</p>
<p><img src="assets/Cgp9HWAeMiSAcga0AAEpsa9onlg651.png" alt="Drawing 0.png" /></p>
<p>数据库类型与 Java 类型对应图表</p>
<p>在使用 PreparedStatement 执行 SQL 语句之前，都是需要手动调用 setInt()、setString() 等 set 方法绑定参数，这不仅仅是告诉 JDBC 一个 SQL 模板中哪个占位符需要使用哪个实参，还会将数据从 Java 类型转换成 JDBC 类型。当从 ResultSet 中获取数据的时候，则是一个逆过程，数据会从 JDBC 类型转换为 Java 类型。</p>
<p>可以使用 MyBatis 中的<strong>类型转换器</strong>，完成上述两次类型转换，如下图所示：</p>
<p><img src="assets/CioPOWAeMi6AdTRAAAENMX_HsyU054.png" alt="Drawing 1.png" /></p>
<p>JDBC 类型数据与 Java 类型数据转换示意图</p>
<h3>深入 TypeHandler</h3>
<p>说了这么多，类型转换器到底是怎么定义的呢？其实，<strong>MyBatis 中的类型转换器就是 TypeHandler 这个接口</strong>，其定义如下：</p>
<pre><code>public interface TypeHandler&lt;T&gt; {

  // 在通过PreparedStatement为SQL语句绑定参数时，会将传入的实参数据由JdbcType类型转换成Java类型

  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;

  // 从ResultSet中获取数据时会使用getResult()方法，其中会将读取到的数据由Java类型转换成JdbcType类型

  T getResult(ResultSet rs, String columnName) throws SQLException;

  T getResult(ResultSet rs, int columnIndex) throws SQLException;

  T getResult(CallableStatement cs, int columnIndex) throws SQLException;

}
</code></pre>
<p><strong>MyBatis 中定义了 BaseTypeHandler 抽象类来实现一些 TypeHandler 的公共逻辑</strong>，BaseTypeHandler 在实现 TypeHandler 的同时，还实现了 TypeReference 抽象类。其继承关系如下图所示：</p>
<p><img src="assets/CioPOWAeMkCANy6LAABJPBfXPJY527.png" alt="Drawing 2.png" /></p>
<p>TypeHandler 继承关系图</p>
<p>在 BaseTypeHandler 中，简单实现了 TypeHandler 接口的 setParameter() 方法和 getResult() 方法。</p>
<ul>
<li>在 setParameter() 实现中，会判断传入的 parameter 实参是否为空，如果为空，则调用 PreparedStatement.setNull() 方法进行设置；如果不为空，则委托 setNonNullParameter() 这个抽象方法进行处理，setNonNullParameter() 方法由 BaseTypeHandler 的子类提供具体实现。</li>
<li>在 getResult() 的三个重载实现中，会直接调用相应的 getNullableResult() 抽象方法，这里有三个重载的 getNullableResult() 抽象方法，它们都由 BaseTypeHandler 的子类提供具体实现。</li>
</ul>
<p>BaseTypeHandler 的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis">源码</a>进行学习。</p>
<p>下图展示了 BaseTypeHandler 的全部实现类，虽然实现类比较多，但是它们的实现方式大同小异。</p>
<p><img src="assets/Cgp9HWAeMkuAI22uAApwhcDLfQ4596.png" alt="Drawing 3.png" /></p>
<p>BaseTypeHandler 实现类示意图</p>
<p>这里我们以 LongTypeHandler 为例进行分析，具体实现如下：</p>
<pre><code>public class LongTypeHandler extends BaseTypeHandler&lt;Long&gt; {

    public void setNonNullParameter(PreparedStatement ps, int i, Long parameter, JdbcType jdbcType)

            throws SQLException {

        // 调用PreparedStatement.setLong()实现参数绑定

        ps.setLong(i, parameter);

    }

    public Long getNullableResult(ResultSet rs, String columnName)

            throws SQLException {

        // 调用ResultSet.getLong()获取指定列值

        long result = rs.getLong(columnName);

        return result == 0 &amp;&amp; rs.wasNull() ? null : result;

    }

    public Long getNullableResult(ResultSet rs, int columnIndex)

            throws SQLException {

        // 调用ResultSet.getLong()获取指定列值

        long result = rs.getLong(columnIndex);

        return result == 0 &amp;&amp; rs.wasNull() ? null : result;

    }

    public Long getNullableResult(CallableStatement cs, int columnIndex)

            throws SQLException {

        // 调用ResultSet.getLong()获取指定列值

        long result = cs.getLong(columnIndex);

        return result == 0 &amp;&amp; cs.wasNull() ? null : result;

    }

}
</code></pre>
<p>可以看到：LongTypeHandler 的核心还是通过 PreparedStatement.setLong() 方法以及 ResultSet.getLong() 方法实现的。至于其他 BaseTypeHandler 的核心实现，同样也是依赖了 JDBC 的 API，这里就不再展开介绍了。</p>
<h3>TypeHandler 注册</h3>
<p>了解了 TypeHandler 接口实现类的核心原理之后，我们就来解决下面两个问题：</p>
<ul>
<li>MyBatis 如何管理这么多的 TypeHandler 接口实现呢？</li>
<li>如何在合适的场景中使用合适的 TypeHandler 实现进行类型转换呢？</li>
</ul>
<p>你若使用过 MyBatis 的话，应该知道我们可以在 mybatis-config.xml 中通过 标签配置自定义的 TypeHandler 实现，也可以在 Mapper.xml 配置文件定义 的时候指定 typeHandler 属性。无论是哪种配置方式，MyBatis 都会在初始化过程中，获取所有已知的 TypeHandler（包括内置实现和自定义实现），然后创建所有 TypeHandler 实例并注册到 TypeHandlerRegistry 中，<strong>由 TypeHandlerRegistry 统一管理所有 TypeHandler 实例</strong>。
TypeHandlerRegistry 管理 TypeHandler 的时候，用到了以下四个最核心的集合。</p>
<ul>
<li>jdbcTypeHandlerMap（Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;类型）：该集合记录了 JdbcType 与 TypeHandler 之间的关联关系。JdbcType 是一个枚举类型，每个 JdbcType 枚举值对应一种 JDBC 类型，例如，JdbcType.VARCHAR 对应的就是 JDBC 中的 varchar 类型。在从 ResultSet 中读取数据的时候，就会从 JDBC_TYPE_HANDLER_MAP 集合中根据 JDBC 类型查找对应的 TypeHandler，将数据转换成 Java 类型。</li>
<li>typeHandlerMap（Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;类型）：该集合第一层 Key 是需要转换的 Java 类型，第二层 Key 是转换的目标 JdbcType，最终的 Value 是完成此次转换时所需要使用的 TypeHandler 对象。那为什么要有两层 Map 的设计呢？这里我们举个例子：Java 类型中的 String 可能转换成数据库中的 varchar、char、text 等多种类型，存在一对多关系，所以就可能有不同的 TypeHandler 实现。</li>
<li>allTypeHandlersMap（Map&lt;Class, TypeHandler&gt;类型）：该集合记录了全部 TypeHandler 的类型以及对应的 TypeHandler 实例对象。</li>
<li>NULL_TYPE_HANDLER_MAP（Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;类型）：空 TypeHandler 集合的标识，默认值为 Collections.emptyMap()。</li>
</ul>
<p>在 MyBatis 初始化的时候，实例化全部 TypeHandler 对象之后，会立即调用 TypeHandlerRegistry 的 register() 方法完成这些 TypeHandler 对象的注册，这个注册过程的核心逻辑就是向上述四个核心集合中添加 TypeHandler 实例以及与 Java 类型、JDBC 类型之间的映射。</p>
<p>TypeHandlerRegistry.register() 方法有多个重载实现，这些重载中最基础的实现是三个参数的重载实现，具体实现如下：</p>
<pre><code>private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) {

    if (javaType != null) { // 检测是否明确指定了TypeHandler能够处理的Java类型

        // 根据指定的Java类型，从typeHandlerMap集合中获取相应的TypeHandler集合

        Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);

        if (map == null || map == NULL_TYPE_HANDLER_MAP) {

            map = new HashMap&lt;&gt;();

        }

        // 将TypeHandler实例记录到typeHandlerMap集合

        map.put(jdbcType, handler);

        typeHandlerMap.put(javaType, map);

    }

    // 向allTypeHandlersMap集合注册TypeHandler类型和对应的TypeHandler对象

    allTypeHandlersMap.put(handler.getClass(), handler);

}
</code></pre>
<p>除了上面的 register() 重载，在有的 register() 重载中会尝试从 TypeHandler 类中的@MappedTypes 注解和 @MappedJdbcTypes 注解中读取信息。其中，<strong>@MappedTypes 注解中可以配置 TypeHandler 实现类能够处理的 Java 类型的集合，@MappedJdbcTypes 注解中可以配置该 TypeHandler 实现类能够处理的 JDBC 类型集合</strong>。</p>
<p>如下就是读取 @MappedJdbcTypes 注解的 register() 重载方法：</p>
<pre><code>private &lt;T&gt; void register(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler) {

    // 尝试从TypeHandler类中获取@MappedJdbcTypes注解

    MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);

    if (mappedJdbcTypes != null) {

        // 根据@MappedJdbcTypes注解指定的JDBC类型进行注册

        for (JdbcType handledJdbcType : mappedJdbcTypes.value()) {

            // 交给前面的三参数重载处理

            register(javaType, handledJdbcType, typeHandler);

        }

        // 如果支持jdbcType为null，也是交给前面的三参数重载处理

        if (mappedJdbcTypes.includeNullJdbcType()) {

            register(javaType, null, typeHandler);

        }

    } else {

        // 如果没有配置MappedJdbcTypes注解，也是交给前面的三参数重载处理

        register(javaType, null, typeHandler);

    }

}
</code></pre>
<p>下面是读取 @MappedTypes 注解的 register() 方法重载：</p>
<pre><code>public &lt;T&gt; void register(TypeHandler&lt;T&gt; typeHandler) {

    boolean mappedTypeFound = false;

    // 读取TypeHandler类中定义的@MappedTypes注解

    MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);

    if (mappedTypes != null) {

        // 根据@MappedTypes注解中指定的Java类型进行注册

        for (Class&lt;?&gt; handledType : mappedTypes.value()) {

            // 交给前面介绍的register()重载读取@MappedJdbcTypes注解并完成注册

            register(handledType, typeHandler);

            mappedTypeFound = true;

        }

    }

    // 从3.1.0版本开始，如果TypeHandler实现类同时继承了TypeReference这个抽象类，

    // 这里会尝试自动查找对应的Java类型

    if (!mappedTypeFound &amp;&amp; typeHandler instanceof TypeReference) {

        try {

            TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;

            // 交给前面介绍的register()重载读取@MappedJdbcTypes注解并完成注册

            register(typeReference.getRawType(), typeHandler);

            mappedTypeFound = true;

        } catch (Throwable t) {

        }

    }

    if (!mappedTypeFound) {

        register((Class&lt;T&gt;) null, typeHandler);

    }

}
</code></pre>
<p>我们接下来看最后一个 register() 重载。<strong>TypeHandlerRegistry 提供了扫描一个包下的全部 TypeHandler 接口实现类的 register() 重载</strong>。在该重载中，会首先读取指定包下面的全部的 TypeHandler 实现类，然后再交给 register() 重载读取 @MappedTypes 注解和 @MappedJdbcTypes 注解，并最终完成注册。这个 register() 重载的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis">源码</a>进行学习。</p>
<p>最后，我们再来看看 TypeHandlerRegistry 的构造方法，其中会通过 register() 方法注册多个 TypeHandler 对象，下面就展示了为 String 类型注册 TypeHandler 的核心实现：</p>
<pre><code>public TypeHandlerRegistry() {

    // StringTypeHandler可以实现String类型与char、varchar、longvarchar类型之间的转换

    register(String.class, JdbcType.CHAR, new StringTypeHandler());

    register(String.class, JdbcType.VARCHAR, new StringTypeHandler());

    register(String.class, JdbcType.LONGVARCHAR, new StringTypeHandler());

    // ClobTypeHandler可以完成String类型与clob类型之间的转换

    register(String.class, JdbcType.CLOB, new ClobTypeHandler());

    // NStringTypeHandler可以完成String类型与NVARCHAR、NCHAR类型之间的转换

    register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler());

    register(String.class, JdbcType.NCHAR, new NStringTypeHandler());

    // NClobTypeHandler可以完成String类型与NCLOB类型之间的转换

    register(String.class, JdbcType.NCLOB, new NClobTypeHandler());

    // 省略其他TypeHandler实现的注册逻辑

}
</code></pre>
<h3>TypeHandler 查询</h3>
<p>分析完注册 TypeHandler 实例的具体实现之后，我们接下来就来看看 MyBatis 是如何从 TypeHandlerRegistry 底层的这几个集合中查找正确的 TypeHandler 实例，<strong>该功能的具体实现是在 TypeHandlerRegistry 的 getTypeHandler() 方法中</strong>。</p>
<p>这里的 getTypeHandler() 方法也有多个重载，最核心的重载是 getTypeHandler(Type,JdbcType) 这个重载方法，其中会根据传入的 Java 类型和 JDBC 类型，从底层的几个集合中查询相应的 TypeHandler 实例，具体实现如下：</p>
<pre><code>private &lt;T&gt; TypeHandler&lt;T&gt; getTypeHandler(Type type, JdbcType jdbcType) {

    if (ParamMap.class.equals(type)) {

        return null; // 过滤掉ParamMap类型

    }

    // 根据Java类型查找对应的TypeHandler集合

    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);

    TypeHandler&lt;?&gt; handler = null;

    if (jdbcHandlerMap != null) {

        // 根据JdbcType类型查找对应的TypeHandler实例

        handler = jdbcHandlerMap.get(jdbcType);

        if (handler == null) {

            // 没有对应的TypeHandler实例，则使用null对应的TypeHandler

            handler = jdbcHandlerMap.get(null);

        }

        if (handler == null) {

            // 如果jdbcHandlerMap只注册了一个TypeHandler，则使用此TypeHandler对象

            handler = pickSoleHandler(jdbcHandlerMap);

        }

    }

    return (TypeHandler&lt;T&gt;) handler;

}
</code></pre>
<p>在 getTypeHandler() 方法中会调用 getJdbcHandlerMap() 方法检测 typeHandlerMap 集合中相应的 TypeHandler 集合是否已经初始化。</p>
<ul>
<li>如果已初始化，则直接使用该集合进行查询；</li>
<li>如果未初始化，则尝试以传入的 Java 类型的、已初始化的父类对应的 TypeHandler 集合作为初始集合；</li>
<li>如果该 Java 类型的父类没有关联任何已初始化的 TypeHandler 集合，则将该 Java 类型对应的 TypeHandler 集合初始化为 NULL_TYPE_HANDLER_MAP 标识。</li>
</ul>
<p>getJdbcHandlerMap() 方法具体实现如下：</p>
<pre><code>private Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; getJdbcHandlerMap(Type type) {

    // 首先查找指定Java类型对应的TypeHandler集合

    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = typeHandlerMap.get(type);

    if (NULL_TYPE_HANDLER_MAP.equals(jdbcHandlerMap)) { // 检测是否为空集合标识

        return null;

    }

    // 初始化指定Java类型的TypeHandler集合

    if (jdbcHandlerMap == null &amp;&amp; type instanceof Class) {

        Class&lt;?&gt; clazz = (Class&lt;?&gt;) type;

        if (Enum.class.isAssignableFrom(clazz)) { // 针对枚举类型的处理

            Class&lt;?&gt; enumClass = clazz.isAnonymousClass() ? clazz.getSuperclass() : clazz;

            jdbcHandlerMap = getJdbcHandlerMapForEnumInterfaces(enumClass, enumClass);

            if (jdbcHandlerMap == null) {

                register(enumClass, getInstance(enumClass, defaultEnumTypeHandler));

                return typeHandlerMap.get(enumClass);

            }

        } else {

            // 查找父类关联的TypeHandler集合，并将其作为clazz对应的TypeHandler集合

            jdbcHandlerMap = getJdbcHandlerMapForSuperclass(clazz);

        }

    }

    // 如果上述查找皆失败，则以NULL_TYPE_HANDLER_MAP作为clazz对应的TypeHandler集合

    typeHandlerMap.put(type, jdbcHandlerMap == null ? 

            NULL_TYPE_HANDLER_MAP : jdbcHandlerMap);

    return jdbcHandlerMap;

}
</code></pre>
<p>这里调用的 getJdbcHandlerMapForSuperclass() 方法会判断传入的 clazz 的父类是否为空或 Object。如果是，则方法直接返回 null；如果不是，则尝试从 typeHandlerMap 集合中获取父类对应的 TypeHandler 集合，但如果父类没有关联 TypeHandler 集合，则递归调用 getJdbcHandlerMapForSuperclass() 方法顺着继承树继续向上查找父类，直到查找到父类的 TypeHandler 集合，然后直接返回。</p>
<p>下面是 getJdbcHandlerMapForSuperclass() 方法的具体实现：</p>
<pre><code>private Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; getJdbcHandlerMapForSuperclass(Class&lt;?&gt; clazz) {

    Class&lt;?&gt; superclass = clazz.getSuperclass();

    if (superclass == null || Object.class.equals(superclass)) {

        return null; // 父类为Object或null则查找结束

    }

    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = typeHandlerMap.get(superclass);

    if (jdbcHandlerMap != null) {

        return jdbcHandlerMap;

    } else {

        // 顺着继承树，递归查找父类对应的TypeHandler集合

        return getJdbcHandlerMapForSuperclass(superclass);

    }

}
</code></pre>
<h3>别名管理</h3>
<p>在《02 | 订单系统持久层示例分析，20 分钟带你快速上手 MyBatis》分析的 MyBatis 示例中，我们在 mybatis-config.xml 配置文件中使用 <code>&lt;typeAlias&gt;</code> 标签为 Customer 等 Java 类的完整名称定义了相应的别名，后续编写 SQL 语句、定义 <code>&lt;resultMap&gt;</code> 的时候，<strong>直接使用这些别名即可完全替代相应的完整 Java 类名，这样就非常易于代码的编写和维护</strong>。</p>
<p><strong>TypeAliasRegistry 是维护别名配置的核心实现所在</strong>，其中提供了别名注册、别名查询的基本功能。在 TypeAliasRegistry 的 typeAliases 字段（Map&lt;String, Class&lt;?&gt;&gt;类型）中记录了别名与 Java 类型之间的对应关系，我们可以通过 registerAlias() 方法完成别名的注册，具体实现如下：</p>
<pre><code>public void registerAlias(String alias, Class&lt;?&gt; value) {

    if (alias == null) { // 传入的别名为null，直接抛出异常

        throw new TypeException(&quot;The parameter alias cannot be null&quot;);

    }

    // 将别名全部转换为小写

    String key = alias.toLowerCase(Locale.ENGLISH);

    // 检测别名是否存在冲突，如果存在冲突，则直接抛出异常

    if (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != null &amp;&amp; !typeAliases.get(key).equals(value)) {

        throw new TypeException(&quot;...&quot;);

    }

    // 在typeAliases集合中记录别名与类之间的映射关系

    typeAliases.put(key, value);

}
</code></pre>
<p>在 TypeAliasRegistry 的构造方法中，会通过上述 registerAlias() 方法将 Java 的基本类型、基本类型的数组类型、基本类型的封装类、封装类型的数组类型、Date、BigDecimal、BigInteger、Map、HashMap、List、ArrayList、Collection、Iterator、ResultSet 等常用类型添加了别名，具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis">源码</a>进行学习。</p>
<p>除了明确传入别名与相应的 Java 类型之外，TypeAliasRegistry 还提供了扫描指定包名下所有的类中的 @Alias 注解获取别名配置，并完成注册的功能，这个功能涉及两个 registerAliases() 方法的重载，相关实现如下：</p>
<pre><code>public void registerAliases(String packageName, Class&lt;?&gt; superType) {

    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();

    // 查找指定包下所有的superType类型

    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);

    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();

    for (Class&lt;?&gt; type : typeSet) {

        // 过滤掉内部类、接口以及抽象类

        if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) {

            // 扫描类中的@Alias注解

            registerAlias(type);

        }

    }

}

public void registerAlias(Class&lt;?&gt; type) {

    // 获取类的简单名称，其中不会包含包名

    String alias = type.getSimpleName();

    // 获取类中的@Alias注解

    Alias aliasAnnotation = type.getAnnotation(Alias.class);

    if (aliasAnnotation != null) { // 获取特定别名

        alias = aliasAnnotation.value();

    }

    // 这里的@Alias注解指定的别名与type类型绑定

    registerAlias(alias, type);

}
</code></pre>
<h3>总结</h3>
<p>在这一讲我们重点介绍了 MyBatis 中 JdbcType 与 Java 类型之间转换的相关实现。</p>
<ul>
<li>首先，介绍了 JdbcType 与 Java 类型之间的常见映射关系，以及两种类型之间转换的基础知识；</li>
<li>然后，深入分析了 TypeHandler 接口及其核心实现，了解了两种类型转换的原理；</li>
<li>接下来，又讲解了 TypeHandler 的注册和查询机制，明确了 MyBatis 是如何管理和使用众多的 TypeHandler 实现；</li>
<li>最后，分析了 MyBatis 中的别名实现。</li>
</ul>
</div>
                    </div>
                    <div>
                        <div style="float: left">
                            <a href="04&#32;&#32;MyBatis&#32;反射工具箱：带你领略不一样的反射设计思路.md">上一页</a>
                        </div>
                        <div style="float: right">
                            <a href="06&#32;&#32;日志框架千千万，MyBatis&#32;都能兼容的秘密是什么？.md">下一页</a>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v64f9daad31f64f81be21cbef6184a5e31634941392597" integrity="sha512-gV/bogrUTVP2N3IzTDKzgP0Js1gg4fbwtYB6ftgLbKQu/V8yH2+lrKCfKHelh4SO3DPzKj4/glTO+tNJGDnb0A==" data-cf-beacon='{"rayId":"6b4356fdeb0b645f","version":"2021.11.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20MyBatis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%AE%8C/&quot;&#32;+&#32;cookie&#32;+&#32;&quot;'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }
</script>

</html>
