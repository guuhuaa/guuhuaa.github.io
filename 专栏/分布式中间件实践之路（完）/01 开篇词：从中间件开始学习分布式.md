<!DOCTYPE html>
<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" href="../../static/favicon.png">
        <title>01 开篇词：从中间件开始学习分布式.md</title>
        <!-- Spectre.css framework -->
        <link rel="stylesheet" href="../../static/index.css">
        <!-- theme css & js -->
        <meta name="generator" content="Hexo 4.2.0">
    </head>

<body>

<div class="book-container">
    <div class="book-sidebar">
        <div class="book-brand">
            <a href="../../index.html">
                <img src="../../static/favicon.png">
                <span>技术文章摘抄</span>
            </a>
        </div>
        <div class="book-menu uncollapsible">
            <ul class="uncollapsible">
                <li><a href="../../index.html" class="current-tab">首页</a></li>
            </ul>

            <ul class="uncollapsible">
                <li><a href="../index.html">上一级</a></li>
            </ul>

            <ul class="uncollapsible">
                <li>

                    <a class="current-tab" href="01&#32;开篇词：从中间件开始学习分布式.md">01 开篇词：从中间件开始学习分布式.md</a>
                    

                </li>
                <li>

                    
                    <a href="02&#32;走进分布式中间件（课前必读）.md">02 走进分布式中间件（课前必读）.md</a>

                </li>
                <li>

                    
                    <a href="03&#32;主流分布式缓存方案的解读及比较.md">03 主流分布式缓存方案的解读及比较.md</a>

                </li>
                <li>

                    
                    <a href="04&#32;分布式一致性协议&#32;Gossip&#32;和&#32;Redis&#32;集群原理解析.md">04 分布式一致性协议 Gossip 和 Redis 集群原理解析.md</a>

                </li>
                <li>

                    
                    <a href="05&#32;基于&#32;Redis&#32;的分布式缓存实现及加固策略.md">05 基于 Redis 的分布式缓存实现及加固策略.md</a>

                </li>
                <li>

                    
                    <a href="06&#32;Redis&#32;实际应用中的异常场景及其根因分析和解决方案.md">06 Redis 实际应用中的异常场景及其根因分析和解决方案.md</a>

                </li>
                <li>

                    
                    <a href="07&#32;Redis-Cluster&#32;故障倒换调优原理分析.md">07 Redis-Cluster 故障倒换调优原理分析.md</a>

                </li>
                <li>

                    
                    <a href="08&#32;基于&#32;Redis&#32;的分布式锁实现及其踩坑案例.md">08 基于 Redis 的分布式锁实现及其踩坑案例.md</a>

                </li>
                <li>

                    
                    <a href="09&#32;分布式一致性算法&#32;Raft&#32;和&#32;Etcd&#32;原理解析.md">09 分布式一致性算法 Raft 和 Etcd 原理解析.md</a>

                </li>
                <li>

                    
                    <a href="10&#32;基于&#32;Etcd&#32;的分布式锁实现原理及方案.md">10 基于 Etcd 的分布式锁实现原理及方案.md</a>

                </li>
                <li>

                    
                    <a href="11&#32;主流的分布式消息队列方案解读及比较.md">11 主流的分布式消息队列方案解读及比较.md</a>

                </li>
                <li>

                    
                    <a href="12&#32;搭建基于&#32;Kafka&#32;和&#32;ZooKeeper&#32;的分布式消息队列.md">12 搭建基于 Kafka 和 ZooKeeper 的分布式消息队列.md</a>

                </li>
                <li>

                    
                    <a href="13&#32;深入解读基于&#32;Kafka&#32;和&#32;ZooKeeper&#32;的分布式消息队列原理.md">13 深入解读基于 Kafka 和 ZooKeeper 的分布式消息队列原理.md</a>

                </li>
                <li>

                    
                    <a href="14&#32;深入浅出解读&#32;Kafka&#32;的可靠性机制.md">14 深入浅出解读 Kafka 的可靠性机制.md</a>

                </li>
            </ul>

        </div>
    </div>

    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
        <div class="sidebar-toggle-inner"></div>
    </div>

    <script>
        function add_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.add('show')
        }

        function remove_inner() {
            let inner = document.querySelector('.sidebar-toggle-inner')
            inner.classList.remove('show')
        }

        function sidebar_toggle() {
            let sidebar_toggle = document.querySelector('.sidebar-toggle')
            let sidebar = document.querySelector('.book-sidebar')
            let content = document.querySelector('.off-canvas-content')
            if (sidebar_toggle.classList.contains('extend')) { // show
                sidebar_toggle.classList.remove('extend')
                sidebar.classList.remove('hide')
                content.classList.remove('extend')
            } else { // hide
                sidebar_toggle.classList.add('extend')
                sidebar.classList.add('hide')
                content.classList.add('extend')
            }
        }
    </script>

    <div class="off-canvas-content">
        <div class="columns">
            <div class="column col-12 col-lg-12">
                <div class="book-navbar">
                    <!-- For Responsive Layout -->
                    <header class="navbar">
                        <section class="navbar-section">
                            <a onclick="open_sidebar()">
                                <i class="icon icon-menu"></i>
                            </a>
                        </section>
                    </header>
                </div>
                <div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
                    <div class="book-post">
                        <p id="tip" align="center"></p>
                        <div><h1>01 开篇词：从中间件开始学习分布式</h1>
<h3>专栏背景</h3>
<p>谈及“分布式系统”，初学者的第一感觉多半是“高大上”和“深不可测”，犹如武林绝学——飞鸟投林、踏浪行波，行走江湖，即便没有见过，也应听过其名。</p>
<p>盛名之下无虚士，分布式系统凭借其高吞吐、高并发、低延迟和负载均衡的特点，迎合了互联网飞速发展背后的巨大承载量需求，民间和官方都有忠实粉丝为其著书立说，然而，大多倾向于理论，对于初学者有一定难度。鉴于此，我期望通过本专栏中的系列文章，用理论与实践结合的方式阐明分布式系统的原理、优势及面临的挑战，进而指导实践。</p>
<p>那么，如何将理论与实践结合呢？切入点的选取是关键，几经考量，我选择了一个最具“通用性”的角度——中间件（Middleware）。如果你不清楚什么是中间件，那你也应该听说过 Redis、Kafka、ZooKeeper、Etcd、RabbitMQ、Nginx 之一，它们都是常用的中间件，可实现缓存、消息队列、锁以及负载均衡等。中间件是基础软件的一大类，属于可复用软件的范畴，顾名思义，中间件处于操作系统软件与用户的应用软件的中间，因此，中间件具有很好的独立性，可作为一个独立的软件系统运转。</p>
<p>随着互联网的飞速发展，高吞吐、高并发、低延迟和负载均衡已成为普遍需求，为此，作为枢纽的中间件也从“集中式”发展为“分布式”——如基于 Redis 的分布式缓存、基于 Kafka 的分布式消息队列、基于 ZooKeeper 的分布式锁等等。青山遮不住，毕竟东流去，随着“云时代”的到来，作为通用软件的中间件再次华丽转身，阿里云、腾讯云、华为云都竞相推出了“云中间件服务”——如 TencentDB for Redis、消息队列 CMQ、云数据库 Redis 等等，几乎应有尽有。</p>
<p>从另一角度来看，作为一名 IT 行业的研发人员，从普通研发工程师到架构师的成长之路上，分布式中间件是绕不过去的。青丝弹指雪，刹那芳华，如果可以，何不从现在开始学习？</p>
<h3>专栏框架</h3>
<p>本专栏从分布式系统切入，首先介绍了集中式系统到分布式系统的演进，并对分布式系统的特性和常见问题进行了阐述。而后进入正题，依次介绍了三大分布式中间件：分布式缓存、分布式锁以及分布式消息队列。</p>
<p>本专栏分为四部分：</p>
<p>第一部分（第01课）：基础篇。</p>
<p>优秀的理论可以指导实践，为了使读者更好的理解分布式系统和中间件，本部分内容以简练的笔触介绍了集中式系统到分布式系统的演进，并对分布式系统的特性和相关理论进行了阐述。最后，从应用场景出发，引出了三大分布式中间件。</p>
<p>第二部分（第02-06课）：分布式缓存。</p>
<p>分布式缓存是应用范围最为广泛的中间件之一，因此最先介绍它。本部分内容首先对当前主流的分布式缓存方案进行了解读；随后浓墨重彩的阐述了 Redis-Cluster 的集群原理和基于 Redis 的分布式缓存实现，并列举了实际应用中 Redis 的典型异常、根因分析及解决方案；最后，结合源码分析了 Redis-Cluster 主节点故障场景下的调优策略。</p>
<p>第三部分（第07-10课）：分布式锁。</p>
<p>在分布式系统中，为保障不同进程争夺共享资源的安全性，需要分布式锁协助。实现分布式锁的方案很多，本部分内容首先对比分析当前主流的分布式锁方案，之后详细解读了基于 Redis 的分布式锁实现和基于 Etcd 的分布式锁实现；特别是 Etcd，作为后起之秀，在很多方面优于 ZooKeeper，但目前在网上几乎找不到完整的方案，鉴于此，本部分对其进行了详细解读。</p>
<p>第四部分（第11-13课）：分布式消息队列。</p>
<p>消息队列是分布式应用间交换信息的重要组件，可以解决应用解耦、异步消息、流量削锋等问题，是实现高性能、高可用、可伸缩和最终一致性架构中不可或缺的一环。本部分内容首先对当前主流的分布式消息队列方案进行了解读，之后深入浅出的阐述了基于 Kafka 的分布式消息队列实现和基于 RocketMQ 的分布式消息队列实现。</p>
<h3>选择本专栏的理由</h3>
<p>如果你正在看这段内容，我相信你对本专栏是感兴趣的，虽然我很期待你选择本专栏，但坦诚地讲，并没有十分具有说服力的理由，选择与否，主要还在于你对 “效率” 这个词的理解。只要你有足够的耐心和时间，本专栏中的部分知识在网上也能找到，当然，我并不推荐这种方式。对于分布式系统、中间件这类需要系统性学习的知识，网络搜索不仅费时费力，而且可信度存疑。</p>
<h4>来自实践，服务实践</h4>
<p>本专栏是我从事中间件研发的经验总结，来自实践，服务于实践。专栏主要包括分布式缓存、分布式锁、分布式消息队列三大部分内容，涉及 Redis、Etcd、Kafka、RocketMQ 等众多主流开源软件的使用方案。不仅提供关键源代码供读者快速实践，而且阐明其中原理并给出踩坑案例和调优分析，致力于授读者以渔。</p>
<h4>理论加持，事半功倍</h4>
<p>在 “多、快、好、省，跑步前进……”的“实用主义”熏陶下，理论二字，很多时候是令人反感的，似乎成了虚无、不切实际、缺乏实践意义的代名词。但凡事不可一概而论，事实证明，成功的实践背后常常有优秀的理论指导。</p>
<p>以 Redis 为例，官方推出的 Redis Cluster 号称最大可支持1000个实例的集群，为什么不可以再多一点，比如2000个呢？又或者这样问：为什么 BAT 都没有采用 Redis Cluster？如果读者知道 Redis Cluster 所采用的分布式一致性协议及其原理，那么一定不难回答上面的问题。</p>
<p>在实践中，理论加持常常可以达到事半功倍的效果，因此，本专栏并不局限于方案的简单实现，而是在介绍方案的同时，对其背后的原理进行了深入浅出的论述。</p>
<h4>方案对比，注重迁移</h4>
<p>没有一种方案可以打遍全场，在中间件选型和方案设计的时候，需结合性能需求、开发成本、可扩展性、可维护性等进行综合评估。例如：基于 ZooKeeper 实现分布式锁的方案非常成熟，参考资料详实，但它并不一定适合你的应用场景，何不考虑一下 Etcd？等等，你是不是根本没有听说过 Etcd？</p>
<p>本专栏介绍了三大中间件：缓存、锁、消息队列，并对每一种中间件的主流实现方案进行了对比分析，以便读者举一反三，迁移应用。</p>
</div>
                    </div>
                    <div>
                        
                        <div style="float: right">
                            <a href="02&#32;走进分布式中间件（课前必读）.md">下一页</a>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v64f9daad31f64f81be21cbef6184a5e31634941392597" integrity="sha512-gV/bogrUTVP2N3IzTDKzgP0Js1gg4fbwtYB6ftgLbKQu/V8yH2+lrKCfKHelh4SO3DPzKj4/glTO+tNJGDnb0A==" data-cf-beacon='{"rayId":"6b434fe7da2a645f","version":"2021.11.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>
</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-NPSEEVD756');
    var path = window.location.pathname
    var cookie = getCookie("lastPath");
    console.log(path)
    if (path.replace("/", "") === "") {
        if (cookie.replace("/", "") !== "") {
            console.log(cookie)
            document.getElementById("tip").innerHTML = "<a href='https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89/&quot;&#32;+&#32;cookie&#32;+&#32;&quot;'>跳转到上次进度</a>"
        }
    } else {
        setCookie("lastPath", path)
    }

    function setCookie(cname, cvalue) {
        var d = new Date();
        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toGMTString();
        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";
    }

    function getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
        }
        return "";
    }
</script>

</html>
